#ifndef _sf_bool_h
#define _sf_bool_h

#ifndef __cplusplus

#if defined(__STDC__) && (__STDC_VERSION__ >= 199901L)

#include <stdbool.h>       /* define bool, true, false */

#else

typedef enum {false, true} Bool;
#define bool _Bool

#endif /* stdbool */

#endif /* c++ */

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_c99_h
#define _sf_c99_h

#ifndef __cplusplus

#include <math.h>

#if !defined(__CYGWIN__) && defined(__STDC__) && (__STDC_VERSION__ >= 199901L)

/* The following from C99 - must define for C90 */
#include <complex.h>
#undef I
#ifdef sun
#define I (1.0fi)
#else
#define I _Complex_I
#endif

#else

#define complex  
#define I 0.0
#define csqrtf  sqrtf
#define clogf   logf
#define clog    log
#define cexpf   expf
#define cexp    exp
#define cpowf   powf
#define cabsf   fabsf
#define cabs    fabs
#define ccosf   cosf
#define csinf   sinf
#define ctanf   tanf
#define cacosf  acosf
#define casinf  asinf
#define catanf  atanf
#define ccoshf  coshf
#define csinhf  sinhf
#define ctanhf  tanhf
#define cacoshf acoshf
#define casinhf asinhf
#define catanhf atanhf
#define crealf  sf_crealf
#define cimagf  sf_cimagf
#define conjf   sf_conjf
#define cargf   sf_cargf
#define creal   sf_creal
#define cimag   sf_cimag
#define conj    sf_conj

#endif

void cprint (float complex c);
/*< print a complex number (for debugging purposes) >*/

#if defined(__CYGWIN__) || !defined (__STDC__) || (__STDC_VERSION__ < 199901L)

float sf_crealf(/*@unused@*/ float complex c) ;
/*< real part of a complex number >*/

float sf_cimagf(/*@unused@*/ float complex c) ;
/*< imaginary part of a complex number >*/

double sf_creal(/*@unused@*/ double complex c) ;
/*< real part of a complex number >*/

double sf_cimag(/*@unused@*/ double complex c) ;
/*< imaginary part of a complex number >*/


float sf_cargf(/*@unused@*/ float complex c);
/*< phase of a complex number >*/

float complex sf_conjf(/*@unused@*/ float complex c);
/*< conjugate of a complex number >*/

double complex sf_conj(/*@unused@*/ double complex c) ;
/*< conjugate of a complex number >*/

float sqrtf(float x) ;
/*< float sqrt >*/

float logf(float x)  ;
/*< float log >*/

float log10f(float x) ;
/*< float log10 >*/

float expf(float x) ;
/*< float exp >*/

float fabsf(float x) ;
/*< float fabs >*/

float floorf(float x);
/*< float floor >*/

float ceilf(float x) ;
/*< float ceil >*/

float fmodf(float x, float y) ;
/*< float fmod >*/

float cosf(float x) ;
/*< float cos >*/

float sinf(float x) ;
/*< float sin >*/

float tanf(float x) ;
/*< float tan >*/

float acosf(float x) ;
/*< float acos >*/

float asinf(float x) ;
/*< float asin >*/

float atanf(float x) ;
/*< float atan >*/

float atan2f(float x, float y) ;
/*< float atan2 >*/

float coshf(float x) ;
/*< float cosh >*/

float sinhf(float x) ;
/*< float sinh >*/

float tanhf(float x) ;
/*< float tanh >*/

float acoshf(float x) ;
/*< float acosh >*/

float asinhf(float x) ;
/*< float asinh >*/

float atanhf(float x) ;
/*< float atanh >*/

float powf(float x, float y) ;
/*< float pow >*/

float hypotf(float x, float y) ;
/*< float hypot >*/

#endif

#endif /* c++ */

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_adjnull_h
#define _sf_adjnull_h


void sf_adjnull (bool adj /* adjoint flag */, 
		 bool add /* addition flag */, 
		 int nx   /* size of x */, 
		 int ny   /* size of y */, 
		 float* x, 
		 float* y) ;
/*< Zeros out the output (unless add is true). 
  Useful first step for any linear operator. >*/

#ifndef __cplusplus

void sf_cadjnull (bool adj /* adjoint flag */, 
		  bool add /* addition flag */, 
		  int nx   /* size of x */, 
		  int ny   /* size of y */, 
		  float complex* x, float complex* y) ;
/*< adjnull version for complex data. >*/

#endif

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_alloc_h
#define _sf_alloc_h

#include <stdlib.h>


/*@out@*/ void *sf_alloc (size_t n    /* number of elements */, 
			  size_t size /* size of one element */);
/*< output-checking allocation >*/

void *sf_realloc (void* ptr   /* previous data */, 
		  size_t n    /* number of elements */, 
		  size_t size /* size of one element */);
/*< output-checing reallocation >*/

/*@out@*/ char *sf_charalloc (size_t n /* number of elements */);
/*< char allocation >*/

/*@out@*/ unsigned char *sf_ucharalloc (size_t n /* number of elements */);
/*< unsigned char allocation >*/

/*@out@*/ int *sf_intalloc (size_t n /* number of elements */);
/*< int allocation >*/

/*@out@*/ float *sf_floatalloc (size_t n /* number of elements */);
/*< float allocation >*/

#ifndef __cplusplus

/*@out@*/ float complex *sf_complexalloc (size_t n /* number of elements */) ;
/*< complex allocation >*/

/*@out@*/ float complex **sf_complexalloc2 (size_t n1 /* fast dimension */, 
					    size_t n2 /* slow dimension */);
/*< complex 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ float complex ***sf_complexalloc3 (size_t n1 /* fast dimension */, 
					     size_t n2 /* slower dimension */, 
					     size_t n3 /* slowest dimension */);
/*< complex 3-D allocation, out[0][0] points to a contiguous array >*/

#endif

/*@out@*/ bool *sf_boolalloc (size_t n /* number of elements */);
/*< bool allocation >*/

/*@out@*/ bool **sf_boolalloc2 (size_t n1 /* fast dimension */, 
				size_t n2 /* slow dimension */);
/*< bool 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ bool ***sf_boolalloc3 (size_t n1 /* fast dimension */, 
				  size_t n2 /* slower dimension */, 
				  size_t n3 /* slowest dimension */);
/*< bool 3-D allocation, out[0][0] points to a contiguous array >*/


/*@out@*/ float **sf_floatalloc2 (size_t n1 /* fast dimension */, 
				  size_t n2 /* slow dimension */);
/*< float 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ float ***sf_floatalloc3 (size_t n1 /* fast dimension */, 
				   size_t n2 /* slower dimension */, 
				   size_t n3 /* slowest dimension */);
/*< float 3-D allocation, out[0][0] points to a contiguous array >*/

/*@out@*/ float ****sf_floatalloc4 (size_t n1 /* fast dimension */, 
				    size_t n2 /* slower dimension */, 
				    size_t n3 /* slower dimension */, 
				    size_t n4 /* slowest dimension */);
/*< float 4-D allocation, out[0][0][0] points to a contiguous array >*/

/*@out@*/ float *****sf_floatalloc5 (size_t n1 /* fast dimension */, 
				     size_t n2 /* slower dimension */, 
				     size_t n3 /* slower dimension */, 
				     size_t n4 /* slower dimension */,
				     size_t n5 /* slowest dimension */);
/*< float 5-D allocation, out[0][0][0][0] points to a contiguous array >*/

/*@out@*/ float ******sf_floatalloc6 (size_t n1 /* fast dimension */, 
				      size_t n2 /* slower dimension */, 
				      size_t n3 /* slower dimension */, 
				      size_t n4 /* slower dimension */,
				      size_t n5 /* slower dimension */,
				      size_t n6 /* slowest dimension */);
/*< float 6-D allocation, out[0][0][0][0][0] points to a contiguous array >*/

/*@out@*/ int **sf_intalloc2 (size_t n1 /* fast dimension */, 
			      size_t n2 /* slow dimension */);
/*< float 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ int ***sf_intalloc3 (size_t n1 /* fast dimension */, 
			       size_t n2 /* slower dimension */, 
			       size_t n3 /* slowest dimension */);
/*< int 3-D allocation, out[0][0] points to a contiguous array >*/


/*@out@*/ char **sf_charalloc2 (size_t n1 /* fast dimension */, 
				size_t n2 /* slow dimension */) ;
/*< char 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ unsigned char **sf_ucharalloc2 (size_t n1 /* fast dimension */, 
					  size_t n2 /* slow dimension */);
/*< unsigned char 2-D allocation, out[0] points to a contiguous array >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_error_h
#define _sf_error_h

void sf_error( char *format, ... );
/*< Outputs an error message to stderr and terminates the program. 
---
Format and variable arguments follow printf convention. Additionally, a ':' at
the end of format adds system information for system errors. >*/

void sf_warning( char *format, ... );
/*< Outputs a warning message to stderr. 
---
Format and variable arguments follow printf convention. Additionally, a ':' at
the end of format adds system information for system errors. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_adjnull_h
#define _sf_adjnull_h


void sf_adjnull (bool adj /* adjoint flag */, 
		 bool add /* addition flag */, 
		 int nx   /* size of x */, 
		 int ny   /* size of y */, 
		 float* x, 
		 float* y) ;
/*< Zeros out the output (unless add is true). 
  Useful first step for any linear operator. >*/

#ifndef __cplusplus

void sf_cadjnull (bool adj /* adjoint flag */, 
		  bool add /* addition flag */, 
		  int nx   /* size of x */, 
		  int ny   /* size of y */, 
		  float complex* x, float complex* y) ;
/*< adjnull version for complex data. >*/

#endif

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_c99_h
#define _sf_c99_h

#ifndef __cplusplus

#include <math.h>

#if !defined(__CYGWIN__) && defined(__STDC__) && (__STDC_VERSION__ >= 199901L)

/* The following from C99 - must define for C90 */
#include <complex.h>
#undef I
#ifdef sun
#define I (1.0fi)
#else
#define I _Complex_I
#endif

#else

#define complex  
#define I 0.0
#define csqrtf  sqrtf
#define clogf   logf
#define clog    log
#define cexpf   expf
#define cexp    exp
#define cpowf   powf
#define cabsf   fabsf
#define cabs    fabs
#define ccosf   cosf
#define csinf   sinf
#define ctanf   tanf
#define cacosf  acosf
#define casinf  asinf
#define catanf  atanf
#define ccoshf  coshf
#define csinhf  sinhf
#define ctanhf  tanhf
#define cacoshf acoshf
#define casinhf asinhf
#define catanhf atanhf
#define crealf  sf_crealf
#define cimagf  sf_cimagf
#define conjf   sf_conjf
#define cargf   sf_cargf
#define creal   sf_creal
#define cimag   sf_cimag
#define conj    sf_conj

#endif

void cprint (float complex c);
/*< print a complex number (for debugging purposes) >*/

#if defined(__CYGWIN__) || !defined (__STDC__) || (__STDC_VERSION__ < 199901L)

float sf_crealf(/*@unused@*/ float complex c) ;
/*< real part of a complex number >*/

float sf_cimagf(/*@unused@*/ float complex c) ;
/*< imaginary part of a complex number >*/

double sf_creal(/*@unused@*/ double complex c) ;
/*< real part of a complex number >*/

double sf_cimag(/*@unused@*/ double complex c) ;
/*< imaginary part of a complex number >*/


float sf_cargf(/*@unused@*/ float complex c);
/*< phase of a complex number >*/

float complex sf_conjf(/*@unused@*/ float complex c);
/*< conjugate of a complex number >*/

double complex sf_conj(/*@unused@*/ double complex c) ;
/*< conjugate of a complex number >*/

float sqrtf(float x) ;
/*< float sqrt >*/

float logf(float x)  ;
/*< float log >*/

float log10f(float x) ;
/*< float log10 >*/

float expf(float x) ;
/*< float exp >*/

float fabsf(float x) ;
/*< float fabs >*/

float floorf(float x);
/*< float floor >*/

float ceilf(float x) ;
/*< float ceil >*/

float fmodf(float x, float y) ;
/*< float fmod >*/

float cosf(float x) ;
/*< float cos >*/

float sinf(float x) ;
/*< float sin >*/

float tanf(float x) ;
/*< float tan >*/

float acosf(float x) ;
/*< float acos >*/

float asinf(float x) ;
/*< float asin >*/

float atanf(float x) ;
/*< float atan >*/

float atan2f(float x, float y) ;
/*< float atan2 >*/

float coshf(float x) ;
/*< float cosh >*/

float sinhf(float x) ;
/*< float sinh >*/

float tanhf(float x) ;
/*< float tanh >*/

float acoshf(float x) ;
/*< float acosh >*/

float asinhf(float x) ;
/*< float asinh >*/

float atanhf(float x) ;
/*< float atanh >*/

float powf(float x, float y) ;
/*< float pow >*/

float hypotf(float x, float y) ;
/*< float hypot >*/

#endif

#endif /* c++ */

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_alloc_h
#define _sf_alloc_h

#include <stdlib.h>


/*@out@*/ void *sf_alloc (size_t n    /* number of elements */, 
			  size_t size /* size of one element */);
/*< output-checking allocation >*/

void *sf_realloc (void* ptr   /* previous data */, 
		  size_t n    /* number of elements */, 
		  size_t size /* size of one element */);
/*< output-checing reallocation >*/

/*@out@*/ char *sf_charalloc (size_t n /* number of elements */);
/*< char allocation >*/

/*@out@*/ unsigned char *sf_ucharalloc (size_t n /* number of elements */);
/*< unsigned char allocation >*/

/*@out@*/ int *sf_intalloc (size_t n /* number of elements */);
/*< int allocation >*/

/*@out@*/ float *sf_floatalloc (size_t n /* number of elements */);
/*< float allocation >*/

#ifndef __cplusplus

/*@out@*/ float complex *sf_complexalloc (size_t n /* number of elements */) ;
/*< complex allocation >*/

/*@out@*/ float complex **sf_complexalloc2 (size_t n1 /* fast dimension */, 
					    size_t n2 /* slow dimension */);
/*< complex 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ float complex ***sf_complexalloc3 (size_t n1 /* fast dimension */, 
					     size_t n2 /* slower dimension */, 
					     size_t n3 /* slowest dimension */);
/*< complex 3-D allocation, out[0][0] points to a contiguous array >*/

#endif

/*@out@*/ bool *sf_boolalloc (size_t n /* number of elements */);
/*< bool allocation >*/

/*@out@*/ bool **sf_boolalloc2 (size_t n1 /* fast dimension */, 
				size_t n2 /* slow dimension */);
/*< bool 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ bool ***sf_boolalloc3 (size_t n1 /* fast dimension */, 
				  size_t n2 /* slower dimension */, 
				  size_t n3 /* slowest dimension */);
/*< bool 3-D allocation, out[0][0] points to a contiguous array >*/


/*@out@*/ float **sf_floatalloc2 (size_t n1 /* fast dimension */, 
				  size_t n2 /* slow dimension */);
/*< float 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ float ***sf_floatalloc3 (size_t n1 /* fast dimension */, 
				   size_t n2 /* slower dimension */, 
				   size_t n3 /* slowest dimension */);
/*< float 3-D allocation, out[0][0] points to a contiguous array >*/

/*@out@*/ float ****sf_floatalloc4 (size_t n1 /* fast dimension */, 
				    size_t n2 /* slower dimension */, 
				    size_t n3 /* slower dimension */, 
				    size_t n4 /* slowest dimension */);
/*< float 4-D allocation, out[0][0][0] points to a contiguous array >*/

/*@out@*/ float *****sf_floatalloc5 (size_t n1 /* fast dimension */, 
				     size_t n2 /* slower dimension */, 
				     size_t n3 /* slower dimension */, 
				     size_t n4 /* slower dimension */,
				     size_t n5 /* slowest dimension */);
/*< float 5-D allocation, out[0][0][0][0] points to a contiguous array >*/

/*@out@*/ float ******sf_floatalloc6 (size_t n1 /* fast dimension */, 
				      size_t n2 /* slower dimension */, 
				      size_t n3 /* slower dimension */, 
				      size_t n4 /* slower dimension */,
				      size_t n5 /* slower dimension */,
				      size_t n6 /* slowest dimension */);
/*< float 6-D allocation, out[0][0][0][0][0] points to a contiguous array >*/

/*@out@*/ int **sf_intalloc2 (size_t n1 /* fast dimension */, 
			      size_t n2 /* slow dimension */);
/*< float 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ int ***sf_intalloc3 (size_t n1 /* fast dimension */, 
			       size_t n2 /* slower dimension */, 
			       size_t n3 /* slowest dimension */);
/*< int 3-D allocation, out[0][0] points to a contiguous array >*/


/*@out@*/ char **sf_charalloc2 (size_t n1 /* fast dimension */, 
				size_t n2 /* slow dimension */) ;
/*< char 2-D allocation, out[0] points to a contiguous array >*/

/*@out@*/ unsigned char **sf_ucharalloc2 (size_t n1 /* fast dimension */, 
					  size_t n2 /* slow dimension */);
/*< unsigned char 2-D allocation, out[0] points to a contiguous array >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_file_h
#define _sf_file_h

#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>

#include <stdio.h>


#define SF_MAX_DIM 9

typedef struct sf_File *sf_file;

typedef enum {SF_UCHAR, SF_CHAR, SF_INT, SF_FLOAT, SF_COMPLEX} sf_datatype;
typedef enum {SF_ASCII, SF_XDR, SF_NATIVE} sf_dataform;

sf_file sf_input (/*@null@*/ const char* tag);
/*< Create an input file structure >*/

sf_file sf_output (/*@null@*/ const char* tag);
/*< Create an output file structure.
---
Should do output after sf_input. >*/

sf_datatype sf_gettype (sf_file file);
/*< return file type >*/

sf_dataform sf_getform (sf_file file);
/*< return file form >*/

size_t sf_esize(sf_file file);
/*< return element size >*/


void sf_settype (sf_file file, sf_datatype type);
/*< set file type >*/

void sf_setpars (sf_file file);
/*< change parameters to those from the command line >*/

void sf_setform (sf_file file, sf_dataform form);
/*< set file form >*/

void sf_setformat (sf_file file, const char* format);
/*< Set file format.
---
format has a form "form_type", i.e. native_float, ascii_int, etc.
>*/

void sf_fileclose (sf_file file) ;
/*< close a file and free allocated space >*/

bool sf_histint (sf_file file, const char* key,/*@out@*/ int* par);
/*< read an int parameter from file >*/

bool sf_histints (sf_file file, const char* key,/*@out@*/ int* par,size_t n) ;
/*< read an int array of size n parameter from file >*/

bool sf_histfloat (sf_file file, const char* key,/*@out@*/ float* par) ;
/*< read a float parameter from file >*/

bool sf_histdouble (sf_file file, const char* key,/*@out@*/ double* par) ;
/*< read a float parameter from file >*/

bool sf_histfloats (sf_file file, const char* key,
		    /*@out@*/ float* par,size_t n) ;
/*< read a float array of size n parameter from file >*/

bool sf_histbool (sf_file file, const char* key,/*@out@*/ bool* par) ;
/*< read a bool parameter from file >*/

bool sf_histbools (sf_file file, const char* key,
		   /*@out@*/ bool* par, size_t n) ;
/*< read a bool array of size n parameter from file >*/

char* sf_histstring (sf_file file, const char* key) ;
/*< read a string parameter from file (returns NULL on failure) >*/

void sf_fileflush (sf_file file, sf_file src);
/*< outputs parameter to a file (initially from source src)
---
Prepares file for writing binary data >*/

void sf_putint (sf_file file, const char* key, int par);
/*< put an int parameter to a file >*/

void sf_putints (sf_file file, const char* key, const int* par, size_t n);
/*< put an int array of size n parameter to a file >*/


void sf_putfloat (sf_file file, const char* key,float par);
/*< put a float parameter to a file >*/

void sf_putstring (sf_file file, const char* key,const char* par);
/*< put a string parameter to a file >*/

void sf_putline (sf_file file, const char* line);
/*< put a string line to a file >*/

void sf_setaformat (const char* format /* number format (.i.e "%5g") */, 
		    int line /* numbers in line */ );
/*< Set format for ascii output >*/

#ifndef __cplusplus

void sf_complexwrite (float complex* arr, size_t size, sf_file file);
/*< write a complex array arr[size] to file >*/

void sf_complexread (/*@out@*/ float complex* arr, size_t size, sf_file file);
/*< read a complex array arr[size] from file >*/

#endif /* c++ */

void sf_charwrite (char* arr, size_t size, sf_file file);
/*< write a char array arr[size] to file >*/

void sf_ucharwrite (unsigned char* arr, size_t size, sf_file file);
/*< write an unsigned char array arr[size] to file >*/

void sf_charread (/*@out@*/ char* arr, size_t size, sf_file file);
/*< read a char array arr[size] from file >*/

void sf_ucharread (/*@out@*/ unsigned char* arr, size_t size, sf_file file);
/*< read a uchar array arr[size] from file >*/

void sf_intwrite (int* arr, size_t size, sf_file file);
/*< write an int array arr[size] to file >*/

void sf_intread (/*@out@*/ int* arr, size_t size, sf_file file);
/*< read an int array arr[size] from file >*/

void sf_floatwrite (float* arr, size_t size, sf_file file);
/*< write a float array arr[size] to file >*/

void sf_floatread (/*@out@*/ float* arr, size_t size, sf_file file);
/*< read a float array arr[size] from file >*/

off_t sf_bytes (sf_file file);
/*< Count the file data size (in bytes) >*/

off_t sf_tell (sf_file file);
/*< Find position in file >*/

FILE *sf_tempfile(char** dataname, const char* mode);
/*< Create a temporary file with a unique name >*/

void sf_seek (sf_file file, off_t offset, int whence);
/*< Seek to a position in file. Follows fseek convention. >*/

void sf_unpipe (sf_file file, off_t size) ;
/*< Redirect a pipe input to a direct access file >*/

void sf_close(void);
/*< Remove temporary file, created by sf_unpipe >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_axa_h
#define _sf_axa_h


typedef struct {
    int     n;
    float o,d;
    char   *l;
} axa;

void iaxa(sf_file FF, axa *AA, const int i) ;
/*< read [n,o,d,l] for axis i >*/

void oaxa(sf_file FF, axa *AA, const int i) ;
/*< write [n,o,d,l] for axis i >*/

void raxa(axa AA) ;
/*< report [n,o,d,l] for axis AA >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_banded_h
#define _sf_banded_h

typedef struct sf_Bands *sf_bands;
/* abstract data type */

sf_bands sf_banded_init (int n    /* matrix size */, 
		   int band /* band size */);
/*< initialize >*/

void sf_banded_define (sf_bands slv, 
		    float* diag  /* diagonal [n] */, 
		    float** offd /* off-diagonal [band][n] */);
/*< define the matrix >*/

void sf_banded_const_define (sf_bands slv, 
			  float diag        /* diagonal */, 
			  const float* offd /* off-diagonal [band] */);
/*< define matrix with constant diagonal coefficients >*/

void sf_banded_solve (sf_bands slv, float* b);
/*< invert (in place) >*/

void sf_banded_close (sf_bands slv);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_c99_h
#define _sf_c99_h

#ifndef __cplusplus

#include <math.h>

#if !defined(__CYGWIN__) && defined(__STDC__) && (__STDC_VERSION__ >= 199901L)

/* The following from C99 - must define for C90 */
#include <complex.h>
#undef I
#ifdef sun
#define I (1.0fi)
#else
#define I _Complex_I
#endif

#else

#define complex  
#define I 0.0
#define csqrtf  sqrtf
#define clogf   logf
#define clog    log
#define cexpf   expf
#define cexp    exp
#define cpowf   powf
#define cabsf   fabsf
#define cabs    fabs
#define ccosf   cosf
#define csinf   sinf
#define ctanf   tanf
#define cacosf  acosf
#define casinf  asinf
#define catanf  atanf
#define ccoshf  coshf
#define csinhf  sinhf
#define ctanhf  tanhf
#define cacoshf acoshf
#define casinhf asinhf
#define catanhf atanhf
#define crealf  sf_crealf
#define cimagf  sf_cimagf
#define conjf   sf_conjf
#define cargf   sf_cargf
#define creal   sf_creal
#define cimag   sf_cimag
#define conj    sf_conj

#endif

void cprint (float complex c);
/*< print a complex number (for debugging purposes) >*/

#if defined(__CYGWIN__) || !defined (__STDC__) || (__STDC_VERSION__ < 199901L)

float sf_crealf(/*@unused@*/ float complex c) ;
/*< real part of a complex number >*/

float sf_cimagf(/*@unused@*/ float complex c) ;
/*< imaginary part of a complex number >*/

double sf_creal(/*@unused@*/ double complex c) ;
/*< real part of a complex number >*/

double sf_cimag(/*@unused@*/ double complex c) ;
/*< imaginary part of a complex number >*/


float sf_cargf(/*@unused@*/ float complex c);
/*< phase of a complex number >*/

float complex sf_conjf(/*@unused@*/ float complex c);
/*< conjugate of a complex number >*/

double complex sf_conj(/*@unused@*/ double complex c) ;
/*< conjugate of a complex number >*/

float sqrtf(float x) ;
/*< float sqrt >*/

float logf(float x)  ;
/*< float log >*/

float log10f(float x) ;
/*< float log10 >*/

float expf(float x) ;
/*< float exp >*/

float fabsf(float x) ;
/*< float fabs >*/

float floorf(float x);
/*< float floor >*/

float ceilf(float x) ;
/*< float ceil >*/

float fmodf(float x, float y) ;
/*< float fmod >*/

float cosf(float x) ;
/*< float cos >*/

float sinf(float x) ;
/*< float sin >*/

float tanf(float x) ;
/*< float tan >*/

float acosf(float x) ;
/*< float acos >*/

float asinf(float x) ;
/*< float asin >*/

float atanf(float x) ;
/*< float atan >*/

float atan2f(float x, float y) ;
/*< float atan2 >*/

float coshf(float x) ;
/*< float cosh >*/

float sinhf(float x) ;
/*< float sinh >*/

float tanhf(float x) ;
/*< float tanh >*/

float acoshf(float x) ;
/*< float acosh >*/

float asinhf(float x) ;
/*< float asinh >*/

float atanhf(float x) ;
/*< float atanh >*/

float powf(float x, float y) ;
/*< float pow >*/

float hypotf(float x, float y) ;
/*< float hypot >*/

#endif

#endif /* c++ */

#endif
/* Operator types for linear solvers. */
/*
  Copyright (C) 2004 University of Texas at Austin
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _sf__solver_h
#define _sf__solver_h


typedef void (*sf_operator)(bool,bool,int,int,float*,float*);
typedef void (*sf_solverstep)(bool,int,int,float*,
			   const float*,float*,const float*);
typedef void (*sf_weight)(int,const float*,float*);
/*^*/

#ifndef __cplusplus
typedef void (*sf_coperator)(bool,bool,int,int,float complex*,float complex*);
typedef void (*sf_csolverstep)(bool,int,int,float complex*,
			       const float complex*,float complex*,
			       const float complex*);
typedef void (*sf_cweight)(int,const float complex*,float*);
#endif 
/*^*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_bigsolver_h
#define _sf_bigsolver_h



void sf_solver_prec (sf_operator oper   /* linear operator */, 
		     sf_solverstep solv /* stepping function */, 
		     sf_operator prec   /* preconditioning operator */, 
		     int nprec          /* size of p */, 
		     int nx             /* size of x */, 
		     int ny             /* size of dat */, 
		     float* x           /* estimated model */, 
		     const float* dat   /* data */, 
		     int niter          /* number of iterations */, 
		     float eps          /* regularization parameter */, 
		     ...                /* variable number of arguments */) ;
/*< Generic preconditioned linear solver.
 ---
 Solves
 oper{x} =~ dat
 eps p   =~ 0
 where x = prec{p}
 ---
 The last parameter in the call to this function should be "end".
 Example: 
 ---
 sf_solver_prec (oper_lop,sf_cgstep,prec_lop,
 np,nx,ny,x,y,100,1.0,"x0",x0,"end");
 ---
 Parameters in ...:
 ... 
 "wt":     float*:         weight      
 "wght":   sf_weight wght: weighting function
 "x0":     float*:         initial model
 "nloper": sf_operator:    nonlinear operator  
 "mwt":    float*:         model weight
 "verb":   bool:           verbosity flag
 "known":  bool*:          known model mask
 "nmem":   int:            iteration memory
 "nfreq":  int:            periodic restart
 "xmov":   float**:        model iteration
 "rmov":   float**:        residual iteration
 "err":    float*:         final error
 "res":    float*:         final residual
 "xp":     float*:         preconditioned model
 >*/

void sf_solver_reg (sf_operator oper   /* linear operator */, 
		    sf_solverstep solv /* stepping function */,
		    sf_operator reg    /* regularization operator */, 
		    int nreg           /* size of reg{x} */, 
		    int nx             /* size of x */, 
		    int ny             /* size of dat */, 
		    float* x           /* estimated model */, 
		    const float* dat   /* data */, 
		    int niter          /* number of iterations */, 
		    float eps          /* regularization parameter */, 
		    ...                /* variable number of arguments */) ;
/*< Generic regularized linear solver.
  ---
  Solves
  oper{x}    =~ dat
  eps reg{x} =~ 0
  ---
  The last parameter in the call to this function should be "end".
  Example: 
  ---
  sf_solver_reg (oper_lop,sf_cgstep,reg_lop,
  np,nx,ny,x,y,100,1.0,"x0",x0,"end");
  ---
  Parameters in ...:
  
  "wt":     float*:         weight      
  "wght":   sf_weight wght: weighting function
  "x0":     float*:         initial model
  "nloper": sf_operator:    nonlinear operator  
  "nlreg":  sf_operator:    nonlinear regularization operator
  "verb":   bool:           verbosity flag
  "known":  bool*:          known model mask
  "nmem":   int:            iteration memory
  "nfreq":  int:            periodic restart
  "xmov":   float**:        model iteration
  "rmov":   float**:        residual iteration
  "err":    float*:         final error
  "res":    float*:         final residual
  "resm":   float*:         final model residual
  >*/

void sf_solver (sf_operator oper   /* linear operator */, 
		sf_solverstep solv /* stepping function */, 
		int nx             /* size of x */, 
		int ny             /* size of dat */, 
		float* x           /* estimated model */, 
		const float* dat   /* data */, 
		int niter          /* number of iterations */, 
		...                /* variable number of arguments */);
/*< Generic linear solver.
  ---
  Solves
  oper{x}    =~ dat
  ---
  The last parameter in the call to this function should be "end".
  Example: 
  ---
  sf_solver (oper_lop,sf_cgstep,nx,ny,x,y,100,"x0",x0,"end");
  ---
  Parameters in ...:
  ---
  "wt":     float*:         weight      
  "wght":   sf_weight wght: weighting function
  "x0":     float*:         initial model
  "nloper": sf_operator:    nonlinear operator  
  "verb":   bool:           verbosity flag
  "known":  bool*:          known model mask
  "nmem":   int:            iteration memory
  "nfreq":  int:            periodic restart
  "xmov":   float**:        model iteration
  "rmov":   float**:        residual iteration
  "err":    float*:         final error
  "res":    float*:         final residual
  >*/

#ifndef __cplusplus

void sf_csolver (sf_coperator oper        /* linear operator */, 
		 sf_csolverstep solv      /* stepping function */, 
		 int nx                   /* size of x */, 
		 int ny                   /* size of dat */, 
		 float complex* x         /* estimated model */, 
		 const float complex* dat /* data */, 
		 int niter                /* number of iterations */, 
		 ...                      /* variable number of arguments */) ;
/*< Generic linear solver for complex data.
  ---
  Solves
  oper{x}    =~ dat
  ---
  The last parameter in the call to this function should be "end".
  Example: 
  ---
  sf_csolver (oper_lop,sf_cgstep,nx,ny,x,y,100,"x0",x0,"end");
  ---
  Parameters in ...:
  ---
  "wt":     float*:          weight      
  "wght":   sf_cweight wght: weighting function
  "x0":     float complex*:  initial model
  "nloper": sf_coperator:    nonlinear operator  
  "verb":   bool:            verbosity flag
  "known":  bool*:           known model mask
  "nmem":   int:             iteration memory
  "nfreq":  int:             periodic restart
  "xmov":   float complex**: model iteration
  "rmov":   float complex**: residual iteration
  "err":    float complex*:  final error
  "res":    float complex*:  final residual
  >*/

#endif

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_causint_h
#define _sf_causint_h


void sf_causint_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_c99_h
#define _sf_c99_h

#ifndef __cplusplus

#include <math.h>

#if !defined(__CYGWIN__) && defined(__STDC__) && (__STDC_VERSION__ >= 199901L)

/* The following from C99 - must define for C90 */
#include <complex.h>
#undef I
#ifdef sun
#define I (1.0fi)
#else
#define I _Complex_I
#endif

#else

#define complex  
#define I 0.0
#define csqrtf  sqrtf
#define clogf   logf
#define clog    log
#define cexpf   expf
#define cexp    exp
#define cpowf   powf
#define cabsf   fabsf
#define cabs    fabs
#define ccosf   cosf
#define csinf   sinf
#define ctanf   tanf
#define cacosf  acosf
#define casinf  asinf
#define catanf  atanf
#define ccoshf  coshf
#define csinhf  sinhf
#define ctanhf  tanhf
#define cacoshf acoshf
#define casinhf asinhf
#define catanhf atanhf
#define crealf  sf_crealf
#define cimagf  sf_cimagf
#define conjf   sf_conjf
#define cargf   sf_cargf
#define creal   sf_creal
#define cimag   sf_cimag
#define conj    sf_conj

#endif

void cprint (float complex c);
/*< print a complex number (for debugging purposes) >*/

#if defined(__CYGWIN__) || !defined (__STDC__) || (__STDC_VERSION__ < 199901L)

float sf_crealf(/*@unused@*/ float complex c) ;
/*< real part of a complex number >*/

float sf_cimagf(/*@unused@*/ float complex c) ;
/*< imaginary part of a complex number >*/

double sf_creal(/*@unused@*/ double complex c) ;
/*< real part of a complex number >*/

double sf_cimag(/*@unused@*/ double complex c) ;
/*< imaginary part of a complex number >*/


float sf_cargf(/*@unused@*/ float complex c);
/*< phase of a complex number >*/

float complex sf_conjf(/*@unused@*/ float complex c);
/*< conjugate of a complex number >*/

double complex sf_conj(/*@unused@*/ double complex c) ;
/*< conjugate of a complex number >*/

float sqrtf(float x) ;
/*< float sqrt >*/

float logf(float x)  ;
/*< float log >*/

float log10f(float x) ;
/*< float log10 >*/

float expf(float x) ;
/*< float exp >*/

float fabsf(float x) ;
/*< float fabs >*/

float floorf(float x);
/*< float floor >*/

float ceilf(float x) ;
/*< float ceil >*/

float fmodf(float x, float y) ;
/*< float fmod >*/

float cosf(float x) ;
/*< float cos >*/

float sinf(float x) ;
/*< float sin >*/

float tanf(float x) ;
/*< float tan >*/

float acosf(float x) ;
/*< float acos >*/

float asinf(float x) ;
/*< float asin >*/

float atanf(float x) ;
/*< float atan >*/

float atan2f(float x, float y) ;
/*< float atan2 >*/

float coshf(float x) ;
/*< float cosh >*/

float sinhf(float x) ;
/*< float sinh >*/

float tanhf(float x) ;
/*< float tanh >*/

float acoshf(float x) ;
/*< float acosh >*/

float asinhf(float x) ;
/*< float asinh >*/

float atanhf(float x) ;
/*< float atanh >*/

float powf(float x, float y) ;
/*< float pow >*/

float hypotf(float x, float y) ;
/*< float hypot >*/

#endif

#endif /* c++ */

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_ccgstep_h
#define _sf_ccgstep_h

#ifndef __cplusplus


void sf_ccgstep( bool forget             /* restart flag */, 
		 int nx                  /* model size */, 
		 int ny                  /* data size */, 
		 float complex* x        /* current model [nx] */,  
		 const float complex* g  /* gradient [nx] */, 
		 float complex* rr       /* data residual [ny] */,
		 const float complex* gg /* conjugate gradient [ny] */) ;
/*< Step of Claerbout's conjugate-gradient iteration for complex operators. 
  The data residual is rr = A x - dat
>*/

void sf_ccgstep_close (void) ;
/*< Free allocated space. >*/

#endif

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_c99_h
#define _sf_c99_h

#ifndef __cplusplus

#include <math.h>

#if !defined(__CYGWIN__) && defined(__STDC__) && (__STDC_VERSION__ >= 199901L)

/* The following from C99 - must define for C90 */
#include <complex.h>
#undef I
#ifdef sun
#define I (1.0fi)
#else
#define I _Complex_I
#endif

#else

#define complex  
#define I 0.0
#define csqrtf  sqrtf
#define clogf   logf
#define clog    log
#define cexpf   expf
#define cexp    exp
#define cpowf   powf
#define cabsf   fabsf
#define cabs    fabs
#define ccosf   cosf
#define csinf   sinf
#define ctanf   tanf
#define cacosf  acosf
#define casinf  asinf
#define catanf  atanf
#define ccoshf  coshf
#define csinhf  sinhf
#define ctanhf  tanhf
#define cacoshf acoshf
#define casinhf asinhf
#define catanhf atanhf
#define crealf  sf_crealf
#define cimagf  sf_cimagf
#define conjf   sf_conjf
#define cargf   sf_cargf
#define creal   sf_creal
#define cimag   sf_cimag
#define conj    sf_conj

#endif

void cprint (float complex c);
/*< print a complex number (for debugging purposes) >*/

#if defined(__CYGWIN__) || !defined (__STDC__) || (__STDC_VERSION__ < 199901L)

float sf_crealf(/*@unused@*/ float complex c) ;
/*< real part of a complex number >*/

float sf_cimagf(/*@unused@*/ float complex c) ;
/*< imaginary part of a complex number >*/

double sf_creal(/*@unused@*/ double complex c) ;
/*< real part of a complex number >*/

double sf_cimag(/*@unused@*/ double complex c) ;
/*< imaginary part of a complex number >*/


float sf_cargf(/*@unused@*/ float complex c);
/*< phase of a complex number >*/

float complex sf_conjf(/*@unused@*/ float complex c);
/*< conjugate of a complex number >*/

double complex sf_conj(/*@unused@*/ double complex c) ;
/*< conjugate of a complex number >*/

float sqrtf(float x) ;
/*< float sqrt >*/

float logf(float x)  ;
/*< float log >*/

float log10f(float x) ;
/*< float log10 >*/

float expf(float x) ;
/*< float exp >*/

float fabsf(float x) ;
/*< float fabs >*/

float floorf(float x);
/*< float floor >*/

float ceilf(float x) ;
/*< float ceil >*/

float fmodf(float x, float y) ;
/*< float fmod >*/

float cosf(float x) ;
/*< float cos >*/

float sinf(float x) ;
/*< float sin >*/

float tanf(float x) ;
/*< float tan >*/

float acosf(float x) ;
/*< float acos >*/

float asinf(float x) ;
/*< float asin >*/

float atanf(float x) ;
/*< float atan >*/

float atan2f(float x, float y) ;
/*< float atan2 >*/

float coshf(float x) ;
/*< float cosh >*/

float sinhf(float x) ;
/*< float sinh >*/

float tanhf(float x) ;
/*< float tanh >*/

float acoshf(float x) ;
/*< float acosh >*/

float asinhf(float x) ;
/*< float asinh >*/

float atanhf(float x) ;
/*< float atanh >*/

float powf(float x, float y) ;
/*< float pow >*/

float hypotf(float x, float y) ;
/*< float hypot >*/

#endif

#endif /* c++ */

#endif
/* Operator types for linear solvers. */
/*
  Copyright (C) 2004 University of Texas at Austin
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _sf__solver_h
#define _sf__solver_h


typedef void (*sf_operator)(bool,bool,int,int,float*,float*);
typedef void (*sf_solverstep)(bool,int,int,float*,
			   const float*,float*,const float*);
typedef void (*sf_weight)(int,const float*,float*);
/*^*/

#ifndef __cplusplus
typedef void (*sf_coperator)(bool,bool,int,int,float complex*,float complex*);
typedef void (*sf_csolverstep)(bool,int,int,float complex*,
			       const float complex*,float complex*,
			       const float complex*);
typedef void (*sf_cweight)(int,const float complex*,float*);
#endif 
/*^*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cconjgrad_h
#define _sf_cconjgrad_h

#ifndef __cplusplus


void sf_cconjgrad_init(int np1     /* preconditioned size */, 
		       int nx1     /* model size */, 
		       int nd1     /* data size */, 
		       int nr1     /* residual size */, 
		       float eps1  /* scaling */,
		       float tol1  /* tolerance */, 
		       bool verb1  /* verbosity flag */, 
		       bool hasp01 /* if has initial model */) ;
/*< solver constructor >*/

void sf_cconjgrad_close(void) ;
/*< Free allocated space >*/

void sf_cconjgrad(sf_coperator prec        /* data preconditioning */, 
		  sf_coperator oper        /* linear operator */, 
		  sf_coperator shape       /* shaping operator */, 
		  float complex* p         /* preconditioned model */, 
		  float complex* x         /* estimated model */, 
		  const float complex* dat /* data */, 
		  int niter                /* number of iterations */);
/*< Conjugate gradient solver with shaping >*/

#endif

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cell_h
#define _sf_cell_h


void sf_cell1_intersect (float a, float x, float dy, float p, 
		      float *sx, int *jx);
/*< intersecting a straight ray with cell boundaries >*/

float sf_cell1_update1 (int dim, float s, float v, float *p, const float *g) ;
/*< symplectic first-order: step 1 >*/


float sf_cell1_update2 (int dim, float s, float v, float *p, const float *g) ;
/*< symplectic first-order: step 2 >*/

void sf_cell11_intersect2 (float a, float da, 
			const float* p, const float* g, 
			float *sp, int *jp);
/*< intersecting a straight ray with cell boundaries >*/

float sf_cell11_update1 (int dim, float s, float v, float *p, const float *g) ;
/*< nonsymplectic first-order: step 1 >*/

float sf_cell11_update2 (int dim, float s, float v, float *p, const float *g) ;
/*< nonsymplectic first-order: step 2 >*/

void sf_cell_intersect (float a, float x, float dy, float p, 
		     float *sx, int *jx);
/*< intersecting a parabolic ray with cell boundaries >*/

bool sf_cell_snap (float *z, int *iz, float eps);
/*< round to the nearest boundary >*/

float sf_cell_update1 (int dim, float s, float v, float *p, const float *g) ;
/*< symplectic second-order: step 1 >*/


float sf_cell_update2 (int dim, float s, float v, float *p, const float *g) ;
/*< symplectic second-order: step 2 >*/

float sf_cell_p2a (float* p);
/*< convert ray parameter to angle >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cdstep_h
#define _sf_cdstep_h


void sf_cdstep_init(void) ;
/*< initialize internal storage >*/

void sf_cdstep_close(void) ;
/*< free internal storage >*/

void sf_cdstep(bool forget     /* restart flag */, 
	       int nx          /* model size */, 
	       int ny          /* data size */, 
	       float* x        /* current model [nx] */, 
	       const float* g  /* gradient [nx] */, 
	       float* rr       /* data residual [ny] */, 
	       const float* gg /* conjugate gradient [ny] */) ;
/*< Step of conjugate-direction iteration. 
  The data residual is rr = A x - dat
>*/

void sf_cdstep_diag(int nx, float *res /* [nx] */);
/*< compute diagonal of the model resolution matrix >*/

void sf_cdstep_mat (int nx, float **res /* [nx][nx] */);
/*< compute complete model resolution matrix >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cgstep_h
#define _sf_cgstep_h


void sf_cgstep( bool forget     /* restart flag */, 
		int nx          /* model size */, 
		int ny          /* data size */, 
		float* x        /* current model [nx] */, 
		const float* g  /* gradient [nx] */, 
		float* rr       /* data residual [ny] */, 
		const float* gg /* conjugate gradient [ny] */) ;
/*< Step of Claerbout's conjugate-gradient iteration. 
  The data residual is rr = A x - dat
>*/

void sf_cgstep_close (void) ;
/*< Free allocated space. >*/

#endif
/* Operator types for linear solvers. */
/*
  Copyright (C) 2004 University of Texas at Austin
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _sf__solver_h
#define _sf__solver_h


typedef void (*sf_operator)(bool,bool,int,int,float*,float*);
typedef void (*sf_solverstep)(bool,int,int,float*,
			   const float*,float*,const float*);
typedef void (*sf_weight)(int,const float*,float*);
/*^*/

#ifndef __cplusplus
typedef void (*sf_coperator)(bool,bool,int,int,float complex*,float complex*);
typedef void (*sf_csolverstep)(bool,int,int,float complex*,
			       const float complex*,float complex*,
			       const float complex*);
typedef void (*sf_cweight)(int,const float complex*,float*);
#endif 
/*^*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_chain_h
#define _sf_chain_h


void sf_chain( sf_operator oper1     /* outer operator */, 
	       sf_operator oper2     /* inner operator */, 
	       bool adj              /* adjoint flag */, 
	       bool add              /* addition flag */, 
	       int nm                /* model size */, 
	       int nd                /* data size */, 
	       int nt                /* intermediate size */, 
	       /*@out@*/ float* mod  /* [nm] model */, 
	       /*@out@*/ float* dat  /* [nd] data */, 
	       float* tmp            /* [nt] intermediate */) ;
/*< Chains two operators, computing oper1{oper2{mod}} or its adjoint.
  The tmp array is used for temporary storage. >*/

void sf_array( sf_operator oper1     /* top operator */, 
	       sf_operator oper2     /* bottom operator */, 
	       bool adj              /* adjoint flag */, 
	       bool add              /* addition flag */, 
	       int nm                /* model size */, 
	       int nd1               /* top data size */, 
	       int nd2               /* bottom data size */, 
	       /*@out@*/ float* mod  /* [nm] model */, 
	       /*@out@*/ float* dat1 /* [nd1] top data */, 
	       /*@out@*/ float* dat2 /* [nd2] bottom data */) ;
/*< Constructs an array of two operators, computing {oper1{mod},oper2{mod}} 
  or its adjoint. >*/

void sf_normal (sf_operator oper /* operator */, 
		bool add         /* addition flag */, 
		int nm           /* model size */, 
		int nd           /* data size */, 
		float *mod       /* [nd] model */, 
		float *dat       /* [nd] data */, 
		float *tmp       /* [nm] intermediate */);
/*< Applies a normal operator (self-adjoint) >*/

void sf_chain3 (sf_operator oper1 /* outer operator */, 
		sf_operator oper2 /* middle operator */, 
		sf_operator oper3 /* inner operator */, 
		bool adj          /* adjoint flag */, 
		bool add          /* addition flag */, 
		int nm            /* model size */, 
		int nt1           /* inner intermediate size */, 
		int nt2           /* outer intermediate size */, 
		int nd            /* data size */, 
		float* mod        /* [nm] model */, 
		float* dat        /* [nd] data */, 
		float* tmp1       /* [nt1] inner intermediate */, 
		float* tmp2       /* [nt2] outer intermediate */);
/*< Chains three operators, computing oper1{oper2{poer3{{mod}}} or its adjoint.
  The tmp1 and tmp2 arrays are used for temporary storage. >*/

#endif
/* Operator types for linear solvers. */
/*
  Copyright (C) 2004 University of Texas at Austin
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _sf__solver_h
#define _sf__solver_h


typedef void (*sf_operator)(bool,bool,int,int,float*,float*);
typedef void (*sf_solverstep)(bool,int,int,float*,
			   const float*,float*,const float*);
typedef void (*sf_weight)(int,const float*,float*);
/*^*/

#ifndef __cplusplus
typedef void (*sf_coperator)(bool,bool,int,int,float complex*,float complex*);
typedef void (*sf_csolverstep)(bool,int,int,float complex*,
			       const float complex*,float complex*,
			       const float complex*);
typedef void (*sf_cweight)(int,const float complex*,float*);
#endif 
/*^*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_conjgrad_h
#define _sf_conjgrad_h


void sf_conjgrad_init(int np1     /* preconditioned size */, 
		      int nx1     /* model size */, 
		      int nd1     /* data size */, 
		      int nr1     /* residual size */, 
		      float eps1  /* scaling */,
		      float tol1  /* tolerance */, 
		      bool verb1  /* verbosity flag */, 
		      bool hasp01 /* if has initial model */) ;
/*< solver constructor >*/

void sf_conjgrad_close(void) ;
/*< Free allocated space >*/

void sf_conjgrad(sf_operator prec  /* data preconditioning */, 
		 sf_operator oper  /* linear operator */, 
		 sf_operator shape /* shaping operator */, 
		 float* p          /* preconditioned model */, 
		 float* x          /* estimated model */, 
		 float* dat        /* data */, 
		 int niter         /* number of iterations */) ;
/*< Conjugate gradient solver with shaping >*/

#endif
/* Operator types for linear solvers. */
/*
  Copyright (C) 2004 University of Texas at Austin
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _sf__solver_h
#define _sf__solver_h


typedef void (*sf_operator)(bool,bool,int,int,float*,float*);
typedef void (*sf_solverstep)(bool,int,int,float*,
			   const float*,float*,const float*);
typedef void (*sf_weight)(int,const float*,float*);
/*^*/

#ifndef __cplusplus
typedef void (*sf_coperator)(bool,bool,int,int,float complex*,float complex*);
typedef void (*sf_csolverstep)(bool,int,int,float complex*,
			       const float complex*,float complex*,
			       const float complex*);
typedef void (*sf_cweight)(int,const float complex*,float*);
#endif 
/*^*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_conjprec_h
#define _sf_conjprec_h


typedef void (*sf_operator2)(int,float*);

void sf_conjprec_init(int nx1     /* preconditioned size */, 
		      int nr1     /* residual size */, 
		      float eps1  /* scaling */,
		      float tol1  /* tolerance */, 
		      bool verb1  /* verbosity flag */, 
		      bool hasp01 /* if has initial model */);
/*< solver constructor >*/

void sf_conjprec_close(void);
/*< Free allocated space >*/

void sf_conjprec(sf_operator oper  /* linear operator */, 
		 sf_operator2 prec /* preconditioning */, 
		 float* p          /* preconditioned */, 
		 float* x          /* model */, 
		 const float* dat  /* data */, 
		 int niter         /* number of iterations */);
/*< Conjugate gradient solver with preconditioning >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_copy_h
#define _sf_copy_h


void sf_copy_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_decart_h
#define _sf_decart_h

void sf_line2cart( int dim       /* number of dimensions */, 
		   const int* nn /* box size [dim] */, 
		   int i         /* line coordinate */, 
		   int* ii       /* cartesian coordinates [dim] */);
/*< Convert line to Cartesian >*/

int sf_cart2line( int dim       /* number of dimensions */, 
		  const int* nn /* box size [dim] */, 
		  const int* ii /* cartesian coordinates [dim] */) ;
/*< Convert Cartesian to line >*/

int sf_first_index (int i        /* dimension [0...dim-1] */, 
		    int j        /* line coordinate */, 
		    int dim      /* number of dimensions */, 
		    const int *n /* box size [dim] */, 
		    const int *s /* step [dim] */);
/*< Find first index for multidimensional transforms >*/

#endif
/* Operator types for linear solvers. */
/*
  Copyright (C) 2004 University of Texas at Austin
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _sf__solver_h
#define _sf__solver_h


typedef void (*sf_operator)(bool,bool,int,int,float*,float*);
typedef void (*sf_solverstep)(bool,int,int,float*,
			   const float*,float*,const float*);
typedef void (*sf_weight)(int,const float*,float*);
/*^*/

#ifndef __cplusplus
typedef void (*sf_coperator)(bool,bool,int,int,float complex*,float complex*);
typedef void (*sf_csolverstep)(bool,int,int,float complex*,
			       const float complex*,float complex*,
			       const float complex*);
typedef void (*sf_cweight)(int,const float complex*,float*);
#endif 
/*^*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_dottest_h
#define _sf_dottest_h


void sf_dot_test(sf_operator oper /* linear operator */, 
		 int nm           /* model size */, 
		 int nd           /* data size */, 
		 float* dot1      /* first output */, 
		 float* dot2      /* second output */) ;
/*< The dot product test to see if the adjoint is coded correctly.
   In the output dot1[0] shpould be equal to dot1[1] 
   (within machine precision),
   and dot2[0] should be equal to dot2[1]. >*/

#endif
#ifndef _sf_defs_h
#define _sf_defs_h

#define SF_MAX(a,b) ((a) < (b) ? (b) : (a))
#define SF_MIN(a,b) ((a) < (b) ? (a) : (b))

#define SF_ABS(a)   ((a) >= 0  ? (a) : (-(a)))

#define SF_SIG(a)   ((a) >= 0  ?  1  :  -1 )

#define SF_PI (3.141592653589793)

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_eno_h
#define _sf_eno_h


typedef struct Eno *sf_eno;
/* abstract data type */

typedef enum {FUNC, DER, BOTH} der;
/* flag values */

sf_eno sf_eno_init (int order /* interpolation order */, 
	      int n     /* data size */);
/*< Initialize interpolation object. >*/

void sf_eno_close (sf_eno ent);
/*< Free internal storage >*/

void sf_eno_set (sf_eno ent, float* c /* data [n] */);
/*< Set the interpolation table. c can be changed or freed afterwords >*/

void sf_eno_apply (sf_eno ent, 
		int i     /* grid location */, 
		float x   /* offset from grid */, 
		float *f  /* output data value */, 
		float *f1 /* output derivative */, 
		der what  /* flag of what to compute */) ;
/*< Apply interpolation >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_eno_h
#define _sf_eno_h


typedef struct Eno *sf_eno;
/* abstract data type */

typedef enum {FUNC, DER, BOTH} der;
/* flag values */

sf_eno sf_eno_init (int order /* interpolation order */, 
	      int n     /* data size */);
/*< Initialize interpolation object. >*/

void sf_eno_close (sf_eno ent);
/*< Free internal storage >*/

void sf_eno_set (sf_eno ent, float* c /* data [n] */);
/*< Set the interpolation table. c can be changed or freed afterwords >*/

void sf_eno_apply (sf_eno ent, 
		int i     /* grid location */, 
		float x   /* offset from grid */, 
		float *f  /* output data value */, 
		float *f1 /* output derivative */, 
		der what  /* flag of what to compute */) ;
/*< Apply interpolation >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_eno2_h
#define _sf_eno2_h


typedef struct Eno2 *sf_eno2;
/* abstract data type */

sf_eno2 sf_eno2_init (int order      /* interpolation order */, 
		int n1, int n2 /* data dimensions */);
/*< Initialize interpolation object >*/

void sf_eno2_set (sf_eno2 pnt, float** c /* data [n2][n1] */);
/*< Set the interpolation table. c can be changed or freed afterwords. >*/

void sf_eno2_set1 (sf_eno2 pnt, float* c /* data [n2*n1] */);
/*< Set the interpolation table. c can be changed or freed afterwords. >*/

void sf_eno2_close (sf_eno2 pnt);
/*< Free internal storage >*/

void sf_eno2_apply (sf_eno2 pnt, 
		 int i, int j     /* grid location */, 
		 float x, float y /* offset from grid */, 
		 float* f         /* output data value */, 
		 float* f1        /* output derivative [2] */,
		 der what         /* what to compute [FUNC,DER,BOTH] */);
/*< Apply interpolation. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_error_h
#define _sf_error_h

void sf_error( char *format, ... );
/*< Outputs an error message to stderr and terminates the program. 
---
Format and variable arguments follow printf convention. Additionally, a ':' at
the end of format adds system information for system errors. >*/

void sf_warning( char *format, ... );
/*< Outputs a warning message to stderr. 
---
Format and variable arguments follow printf convention. Additionally, a ':' at
the end of format adds system information for system errors. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_file_h
#define _sf_file_h

#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>

#include <stdio.h>


#define SF_MAX_DIM 9

typedef struct sf_File *sf_file;

typedef enum {SF_UCHAR, SF_CHAR, SF_INT, SF_FLOAT, SF_COMPLEX} sf_datatype;
typedef enum {SF_ASCII, SF_XDR, SF_NATIVE} sf_dataform;

sf_file sf_input (/*@null@*/ const char* tag);
/*< Create an input file structure >*/

sf_file sf_output (/*@null@*/ const char* tag);
/*< Create an output file structure.
---
Should do output after sf_input. >*/

sf_datatype sf_gettype (sf_file file);
/*< return file type >*/

sf_dataform sf_getform (sf_file file);
/*< return file form >*/

size_t sf_esize(sf_file file);
/*< return element size >*/


void sf_settype (sf_file file, sf_datatype type);
/*< set file type >*/

void sf_setpars (sf_file file);
/*< change parameters to those from the command line >*/

void sf_setform (sf_file file, sf_dataform form);
/*< set file form >*/

void sf_setformat (sf_file file, const char* format);
/*< Set file format.
---
format has a form "form_type", i.e. native_float, ascii_int, etc.
>*/

void sf_fileclose (sf_file file) ;
/*< close a file and free allocated space >*/

bool sf_histint (sf_file file, const char* key,/*@out@*/ int* par);
/*< read an int parameter from file >*/

bool sf_histints (sf_file file, const char* key,/*@out@*/ int* par,size_t n) ;
/*< read an int array of size n parameter from file >*/

bool sf_histfloat (sf_file file, const char* key,/*@out@*/ float* par) ;
/*< read a float parameter from file >*/

bool sf_histdouble (sf_file file, const char* key,/*@out@*/ double* par) ;
/*< read a float parameter from file >*/

bool sf_histfloats (sf_file file, const char* key,
		    /*@out@*/ float* par,size_t n) ;
/*< read a float array of size n parameter from file >*/

bool sf_histbool (sf_file file, const char* key,/*@out@*/ bool* par) ;
/*< read a bool parameter from file >*/

bool sf_histbools (sf_file file, const char* key,
		   /*@out@*/ bool* par, size_t n) ;
/*< read a bool array of size n parameter from file >*/

char* sf_histstring (sf_file file, const char* key) ;
/*< read a string parameter from file (returns NULL on failure) >*/

void sf_fileflush (sf_file file, sf_file src);
/*< outputs parameter to a file (initially from source src)
---
Prepares file for writing binary data >*/

void sf_putint (sf_file file, const char* key, int par);
/*< put an int parameter to a file >*/

void sf_putints (sf_file file, const char* key, const int* par, size_t n);
/*< put an int array of size n parameter to a file >*/


void sf_putfloat (sf_file file, const char* key,float par);
/*< put a float parameter to a file >*/

void sf_putstring (sf_file file, const char* key,const char* par);
/*< put a string parameter to a file >*/

void sf_putline (sf_file file, const char* line);
/*< put a string line to a file >*/

void sf_setaformat (const char* format /* number format (.i.e "%5g") */, 
		    int line /* numbers in line */ );
/*< Set format for ascii output >*/

#ifndef __cplusplus

void sf_complexwrite (float complex* arr, size_t size, sf_file file);
/*< write a complex array arr[size] to file >*/

void sf_complexread (/*@out@*/ float complex* arr, size_t size, sf_file file);
/*< read a complex array arr[size] from file >*/

#endif /* c++ */

void sf_charwrite (char* arr, size_t size, sf_file file);
/*< write a char array arr[size] to file >*/

void sf_ucharwrite (unsigned char* arr, size_t size, sf_file file);
/*< write an unsigned char array arr[size] to file >*/

void sf_charread (/*@out@*/ char* arr, size_t size, sf_file file);
/*< read a char array arr[size] from file >*/

void sf_ucharread (/*@out@*/ unsigned char* arr, size_t size, sf_file file);
/*< read a uchar array arr[size] from file >*/

void sf_intwrite (int* arr, size_t size, sf_file file);
/*< write an int array arr[size] to file >*/

void sf_intread (/*@out@*/ int* arr, size_t size, sf_file file);
/*< read an int array arr[size] from file >*/

void sf_floatwrite (float* arr, size_t size, sf_file file);
/*< write a float array arr[size] to file >*/

void sf_floatread (/*@out@*/ float* arr, size_t size, sf_file file);
/*< read a float array arr[size] from file >*/

off_t sf_bytes (sf_file file);
/*< Count the file data size (in bytes) >*/

off_t sf_tell (sf_file file);
/*< Find position in file >*/

FILE *sf_tempfile(char** dataname, const char* mode);
/*< Create a temporary file with a unique name >*/

void sf_seek (sf_file file, off_t offset, int whence);
/*< Seek to a position in file. Follows fseek convention. >*/

void sf_unpipe (sf_file file, off_t size) ;
/*< Redirect a pipe input to a direct access file >*/

void sf_close(void);
/*< Remove temporary file, created by sf_unpipe >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_files_h
#define _sf_files_h


int sf_filedims (sf_file file, /*@out@*/ int *n) ;
/*< Find file dimensions.
--- 
Outputs the number of dimensions dim and a dimension array n[dim] >*/

int sf_filesize (sf_file file) ;
/*< Find file size (product of all dimensions) >*/

int sf_leftsize (sf_file file, int dim) ;
/*< Find file size for dimensions greater than dim >*/

void sf_cp(sf_file in, sf_file out);
/*< Copy file in to file out >*/

void sf_rm(const char* filename, bool force, bool verb, bool inquire);
/*< Remove an RSF file.
---
force, verb, and inquire flags should behave similar to the corresponding flags in the Unix "rm" command. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_c99_h
#define _sf_c99_h

#ifndef __cplusplus

#include <math.h>

#if !defined(__CYGWIN__) && defined(__STDC__) && (__STDC_VERSION__ >= 199901L)

/* The following from C99 - must define for C90 */
#include <complex.h>
#undef I
#ifdef sun
#define I (1.0fi)
#else
#define I _Complex_I
#endif

#else

#define complex  
#define I 0.0
#define csqrtf  sqrtf
#define clogf   logf
#define clog    log
#define cexpf   expf
#define cexp    exp
#define cpowf   powf
#define cabsf   fabsf
#define cabs    fabs
#define ccosf   cosf
#define csinf   sinf
#define ctanf   tanf
#define cacosf  acosf
#define casinf  asinf
#define catanf  atanf
#define ccoshf  coshf
#define csinhf  sinhf
#define ctanhf  tanhf
#define cacoshf acoshf
#define casinhf asinhf
#define catanhf atanhf
#define crealf  sf_crealf
#define cimagf  sf_cimagf
#define conjf   sf_conjf
#define cargf   sf_cargf
#define creal   sf_creal
#define cimag   sf_cimag
#define conj    sf_conj

#endif

void cprint (float complex c);
/*< print a complex number (for debugging purposes) >*/

#if defined(__CYGWIN__) || !defined (__STDC__) || (__STDC_VERSION__ < 199901L)

float sf_crealf(/*@unused@*/ float complex c) ;
/*< real part of a complex number >*/

float sf_cimagf(/*@unused@*/ float complex c) ;
/*< imaginary part of a complex number >*/

double sf_creal(/*@unused@*/ double complex c) ;
/*< real part of a complex number >*/

double sf_cimag(/*@unused@*/ double complex c) ;
/*< imaginary part of a complex number >*/


float sf_cargf(/*@unused@*/ float complex c);
/*< phase of a complex number >*/

float complex sf_conjf(/*@unused@*/ float complex c);
/*< conjugate of a complex number >*/

double complex sf_conj(/*@unused@*/ double complex c) ;
/*< conjugate of a complex number >*/

float sqrtf(float x) ;
/*< float sqrt >*/

float logf(float x)  ;
/*< float log >*/

float log10f(float x) ;
/*< float log10 >*/

float expf(float x) ;
/*< float exp >*/

float fabsf(float x) ;
/*< float fabs >*/

float floorf(float x);
/*< float floor >*/

float ceilf(float x) ;
/*< float ceil >*/

float fmodf(float x, float y) ;
/*< float fmod >*/

float cosf(float x) ;
/*< float cos >*/

float sinf(float x) ;
/*< float sin >*/

float tanf(float x) ;
/*< float tan >*/

float acosf(float x) ;
/*< float acos >*/

float asinf(float x) ;
/*< float asin >*/

float atanf(float x) ;
/*< float atan >*/

float atan2f(float x, float y) ;
/*< float atan2 >*/

float coshf(float x) ;
/*< float cosh >*/

float sinhf(float x) ;
/*< float sinh >*/

float tanhf(float x) ;
/*< float tanh >*/

float acoshf(float x) ;
/*< float acosh >*/

float asinhf(float x) ;
/*< float asinh >*/

float atanhf(float x) ;
/*< float atanh >*/

float powf(float x, float y) ;
/*< float pow >*/

float hypotf(float x, float y) ;
/*< float hypot >*/

#endif

#endif /* c++ */

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_freqfilt_h
#define _sf_freqfilt_h


#ifndef __cplusplus

void sf_freqfilt_init(int nfft1 /* time samples (possibly padded) */, 
		      int nw1   /* frequency samples */);
/*< Initialize >*/

void sf_freqfilt_set(float *filt /* frequency filter [nw] */);
/*< Initialize filter (zero-phase) >*/

#ifndef __cplusplus

void sf_freqfilt_cset(float complex *filt /* frequency filter [nw] */);
/*< Initialize filter >*/

#endif

void sf_freqfilt_close(void) ;
/*< Free allocated storage >*/

void sf_freqfilt(int nx, float* x);
/*< Filtering in place >*/

void sf_freqfilt_lop (bool adj, bool add, int nx, int ny, float* x, float* y) ;
/*< Filtering as linear operator >*/

#endif

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_simtab_h
#define _sf_simtab_h

#include <stdio.h>


#define SF_EOL '\014'
#define SF_EOT '\004'

typedef struct sf_SimTab *sf_simtab; /* Simbol Table structure */

sf_simtab sf_simtab_init(int size);
/*< Create simbol table. >*/

void sf_simtab_close(sf_simtab table);
/*< Free allocated memory >*/

void sf_simtab_enter(sf_simtab table, const char *key, const char* val);
/*< Add an entry key=val to the table >*/

char *sf_simtab_get(sf_simtab table, const char *key) ;
/*< extract a value from the table >*/

bool sf_simtab_getint (sf_simtab table, const char* key,/*@out@*/ int* par);
/*< extract an int parameter from the table >*/

bool sf_simtab_getfloat (sf_simtab table, const char* key,/*@out@*/ float* par);
/*< extract a float parameter from the table >*/

bool sf_simtab_getdouble (sf_simtab table, const char* key,/*@out@*/ double* par);
/*< extract a double parameter from the table >*/

bool sf_simtab_getfloats (sf_simtab table, const char* key,
			  /*@out@*/ float* par,size_t n);
/*< extract a float array parameter from the table >*/

char* sf_simtab_getstring (sf_simtab table, const char* key) ;
/*< extract a string parameter from the table >*/

bool sf_simtab_getbool (sf_simtab table, const char* key,/*@out@*/ bool *par);
/*< extract a bool parameter from the table >*/

bool sf_simtab_getbools (sf_simtab table, const char* key,
			 /*@out@*/bool *par,size_t n);
/*< extract a bool array parameter from the table >*/

bool sf_simtab_getints (sf_simtab table, const char* key,
			/*@out@*/ int *par,size_t n);
/*< extract an int array parameter from the table >*/

bool sf_simtab_getstrings (sf_simtab table, const char* key,
			   /*@out@*/ char **par,size_t n);
/*< extract a string array parameter from the table >*/

void sf_simtab_put (sf_simtab table, const char *keyval) ;
/*< put a key=val string to the table >*/

void sf_simtab_input (sf_simtab table, FILE* fp) ;
/*< extract parameters from a file >*/

void sf_simtab_output (sf_simtab table, FILE* fp) ;
/*< output parameters to a file >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_getpar_h
#define _sf_getpar_h


void sf_init(int argc,char *argv[]) ;
/*< initialize parameter table from command-line arguments >*/

void sf_parclose (void);
/*< close parameter table and free space >*/

void sf_parout (FILE *file);
/*< write the parameters to a file >*/

char* sf_getprog (void) ;
/*< returns name of the running program >*/

char* sf_getuser (void) ;
/*< returns user name >*/

char* sf_gethost (void) ;
/*< returns host name >*/

bool sf_getint (const char* key,/*@out@*/ int* par) ;
/*< get an int parameter from the command line >*/

bool sf_getints (const char* key,/*@out@*/ int* par,size_t n) ;
/*< get an int array parameter (comma-separated) from the command line >*/

bool sf_getfloat (const char* key,/*@out@*/ float* par) ;
/*< get a float parameter from the command line >*/

bool sf_getdouble (const char* key,/*@out@*/ double* par) ;
/*< get a double parameter from the command line >*/

bool sf_getfloats (const char* key,/*@out@*/ float* par,size_t n) ;
/*< get a float array parameter from the command line >*/

char* sf_getstring (const char* key) ;
/*< get a string parameter from the command line >*/

bool sf_getstrings (const char* key,/*@out@*/ char** par,size_t n) ;
/*< get a string array parameter from the command line >*/

bool sf_getbool (const char* key,/*@out@*/ bool* par);
/*< get a bool parameter from the command line >*/

bool sf_getbools (const char* key,/*@out@*/ bool* par,size_t n) ;
/*< get a bool array parameter from the command line >*/

sf_simtab sf_getpars (void);
/*< provide access to the parameter table >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_interp_h
#define _sf_interp_h

typedef void (*sf_interpolator)(float,int,float*);
/* generic interpolation interface */

void sf_bin_int (float x, int n, float* w) ;
/*< nearest neighbor >*/

void sf_lin_int (float x, int n, float* w) ;
/*< linear >*/

void sf_lg_int (float x, int n, float* w) ;
/*< Lagrangian >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_int1_h
#define _sf_int1_h


void  sf_int1_init (float* coord               /* cooordinates [nd] */, 
		 float o1, float d1, int n1 /* axis */, 
		 sf_interpolator interp     /* interpolation function */, 
		 int nf_in                  /* interpolator length */, 
		 int nd_in                  /* number of data points */);
/*< initialize >*/

void  sf_int1_lop (bool adj, bool add, int nm, int ny, float* x, float* ord);
/*< linear operator >*/

void sf_int1_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_interp_h
#define _sf_interp_h

typedef void (*sf_interpolator)(float,int,float*);
/* generic interpolation interface */

void sf_bin_int (float x, int n, float* w) ;
/*< nearest neighbor >*/

void sf_lin_int (float x, int n, float* w) ;
/*< linear >*/

void sf_lg_int (float x, int n, float* w) ;
/*< Lagrangian >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_int2_h
#define _sf_int2_h



void  sf_int2_init (float** coord          /* coordinates [nd][2] */, 
		    float o1, float o2, 
		    float d1, float d2,
		    int n1, int n2         /* axes */, 
		    sf_interpolator interp /* interpolation function */, 
		    int nf_in              /* interpolator length */, 
		    int nd_in              /* number of data points */);
/*< initialize >*/

void  sf_int2_lop (bool adj, bool add, int nm, int ny, float* x, float* ord);
/*< linear operator >*/

void int2_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_interp_spline_h
#define _sf_interp_spline_h

void sf_spline_int (float x, int n, float* w);
/*< interpolation function >*/

void sf_spline_der (float x, int n, float* w);
/*< derivative computation >*/

void sf_spline4_int (float x, float* w);
/*< Cubic spline interpolation >*/

void sf_spline4_der (float x, float* w);
/*< Cubic spline derivative >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_irls_h
#define _sf_irls_h

void sf_irls_init(int n) ;
/*< Initialize with data size >*/

void sf_irls_close(void) ;
/*< free allocated storage >*/

void sf_l1 (int n, const float *res, float *weight)  ;
/*< weighting for L1 norm >*/

void sf_cauchy (int n, const float *res, float *weight)  ;
/*< weighting for Cauchy norm >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_llist_h
#define _sf_llist_h

typedef struct sf_List *sf_list;
/* abstract data type */

sf_list sf_llist_init(void);
/*< create an empty list >*/

void sf_llist_rewind(sf_list l);
/*< return to the start >*/

int sf_llist_depth(sf_list l);
/*< return list depth >*/

void sf_llist_add(sf_list l, float *g, double gn) ;
/*< add an entry in the list >*/

void sf_llist_down(sf_list l, float **g, double *gn);
/*< extract and entry from the list >*/

void sf_llist_close(sf_list l) ;
/*< free allocated storage >*/

void sf_llist_chop(sf_list l) ;
/*< free the top entry from the list >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_mask_h
#define _sf_mask_h


void sf_mask_init(const bool *m_in);
/*< initialize with mask >*/

void sf_mask_lop(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_file_h
#define _sf_file_h

#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>

#include <stdio.h>


#define SF_MAX_DIM 9

typedef struct sf_File *sf_file;

typedef enum {SF_UCHAR, SF_CHAR, SF_INT, SF_FLOAT, SF_COMPLEX} sf_datatype;
typedef enum {SF_ASCII, SF_XDR, SF_NATIVE} sf_dataform;

sf_file sf_input (/*@null@*/ const char* tag);
/*< Create an input file structure >*/

sf_file sf_output (/*@null@*/ const char* tag);
/*< Create an output file structure.
---
Should do output after sf_input. >*/

sf_datatype sf_gettype (sf_file file);
/*< return file type >*/

sf_dataform sf_getform (sf_file file);
/*< return file form >*/

size_t sf_esize(sf_file file);
/*< return element size >*/


void sf_settype (sf_file file, sf_datatype type);
/*< set file type >*/

void sf_setpars (sf_file file);
/*< change parameters to those from the command line >*/

void sf_setform (sf_file file, sf_dataform form);
/*< set file form >*/

void sf_setformat (sf_file file, const char* format);
/*< Set file format.
---
format has a form "form_type", i.e. native_float, ascii_int, etc.
>*/

void sf_fileclose (sf_file file) ;
/*< close a file and free allocated space >*/

bool sf_histint (sf_file file, const char* key,/*@out@*/ int* par);
/*< read an int parameter from file >*/

bool sf_histints (sf_file file, const char* key,/*@out@*/ int* par,size_t n) ;
/*< read an int array of size n parameter from file >*/

bool sf_histfloat (sf_file file, const char* key,/*@out@*/ float* par) ;
/*< read a float parameter from file >*/

bool sf_histdouble (sf_file file, const char* key,/*@out@*/ double* par) ;
/*< read a float parameter from file >*/

bool sf_histfloats (sf_file file, const char* key,
		    /*@out@*/ float* par,size_t n) ;
/*< read a float array of size n parameter from file >*/

bool sf_histbool (sf_file file, const char* key,/*@out@*/ bool* par) ;
/*< read a bool parameter from file >*/

bool sf_histbools (sf_file file, const char* key,
		   /*@out@*/ bool* par, size_t n) ;
/*< read a bool array of size n parameter from file >*/

char* sf_histstring (sf_file file, const char* key) ;
/*< read a string parameter from file (returns NULL on failure) >*/

void sf_fileflush (sf_file file, sf_file src);
/*< outputs parameter to a file (initially from source src)
---
Prepares file for writing binary data >*/

void sf_putint (sf_file file, const char* key, int par);
/*< put an int parameter to a file >*/

void sf_putints (sf_file file, const char* key, const int* par, size_t n);
/*< put an int array of size n parameter to a file >*/


void sf_putfloat (sf_file file, const char* key,float par);
/*< put a float parameter to a file >*/

void sf_putstring (sf_file file, const char* key,const char* par);
/*< put a string parameter to a file >*/

void sf_putline (sf_file file, const char* line);
/*< put a string line to a file >*/

void sf_setaformat (const char* format /* number format (.i.e "%5g") */, 
		    int line /* numbers in line */ );
/*< Set format for ascii output >*/

#ifndef __cplusplus

void sf_complexwrite (float complex* arr, size_t size, sf_file file);
/*< write a complex array arr[size] to file >*/

void sf_complexread (/*@out@*/ float complex* arr, size_t size, sf_file file);
/*< read a complex array arr[size] from file >*/

#endif /* c++ */

void sf_charwrite (char* arr, size_t size, sf_file file);
/*< write a char array arr[size] to file >*/

void sf_ucharwrite (unsigned char* arr, size_t size, sf_file file);
/*< write an unsigned char array arr[size] to file >*/

void sf_charread (/*@out@*/ char* arr, size_t size, sf_file file);
/*< read a char array arr[size] from file >*/

void sf_ucharread (/*@out@*/ unsigned char* arr, size_t size, sf_file file);
/*< read a uchar array arr[size] from file >*/

void sf_intwrite (int* arr, size_t size, sf_file file);
/*< write an int array arr[size] to file >*/

void sf_intread (/*@out@*/ int* arr, size_t size, sf_file file);
/*< read an int array arr[size] from file >*/

void sf_floatwrite (float* arr, size_t size, sf_file file);
/*< write a float array arr[size] to file >*/

void sf_floatread (/*@out@*/ float* arr, size_t size, sf_file file);
/*< read a float array arr[size] from file >*/

off_t sf_bytes (sf_file file);
/*< Count the file data size (in bytes) >*/

off_t sf_tell (sf_file file);
/*< Find position in file >*/

FILE *sf_tempfile(char** dataname, const char* mode);
/*< Create a temporary file with a unique name >*/

void sf_seek (sf_file file, off_t offset, int whence);
/*< Seek to a position in file. Follows fseek convention. >*/

void sf_unpipe (sf_file file, off_t size) ;
/*< Redirect a pipe input to a direct access file >*/

void sf_close(void);
/*< Remove temporary file, created by sf_unpipe >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_math1_h
#define _sf_math1_h



void sf_math_evaluate (int len /* stack length */, 
		       int nbuf /* buffer length */, 
		       float** fbuf /* number buffers */, 
		       float** fst /* stack */);
/*< Evaluate a mathematical expression from stack (float numbers) >*/

#ifndef __cplusplus

void sf_complex_math_evaluate (int len              /* stack length */, 
			       int nbuf             /* buffer length */, 
			       float complex** fbuf /* number buffers */, 
			       float complex** fst  /* stack */);
/*< Evaluate a mathematical expression from stack (complex numbers) >*/

#endif

size_t sf_math_parse (char* output /* expression */, 
		      sf_file out  /* parameter file */,
		      sf_datatype datatype);
/*< Parse a mathematical expression, returns stack length >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_file_h
#define _sf_file_h

#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>

#include <stdio.h>


#define SF_MAX_DIM 9

typedef struct sf_File *sf_file;

typedef enum {SF_UCHAR, SF_CHAR, SF_INT, SF_FLOAT, SF_COMPLEX} sf_datatype;
typedef enum {SF_ASCII, SF_XDR, SF_NATIVE} sf_dataform;

sf_file sf_input (/*@null@*/ const char* tag);
/*< Create an input file structure >*/

sf_file sf_output (/*@null@*/ const char* tag);
/*< Create an output file structure.
---
Should do output after sf_input. >*/

sf_datatype sf_gettype (sf_file file);
/*< return file type >*/

sf_dataform sf_getform (sf_file file);
/*< return file form >*/

size_t sf_esize(sf_file file);
/*< return element size >*/


void sf_settype (sf_file file, sf_datatype type);
/*< set file type >*/

void sf_setpars (sf_file file);
/*< change parameters to those from the command line >*/

void sf_setform (sf_file file, sf_dataform form);
/*< set file form >*/

void sf_setformat (sf_file file, const char* format);
/*< Set file format.
---
format has a form "form_type", i.e. native_float, ascii_int, etc.
>*/

void sf_fileclose (sf_file file) ;
/*< close a file and free allocated space >*/

bool sf_histint (sf_file file, const char* key,/*@out@*/ int* par);
/*< read an int parameter from file >*/

bool sf_histints (sf_file file, const char* key,/*@out@*/ int* par,size_t n) ;
/*< read an int array of size n parameter from file >*/

bool sf_histfloat (sf_file file, const char* key,/*@out@*/ float* par) ;
/*< read a float parameter from file >*/

bool sf_histdouble (sf_file file, const char* key,/*@out@*/ double* par) ;
/*< read a float parameter from file >*/

bool sf_histfloats (sf_file file, const char* key,
		    /*@out@*/ float* par,size_t n) ;
/*< read a float array of size n parameter from file >*/

bool sf_histbool (sf_file file, const char* key,/*@out@*/ bool* par) ;
/*< read a bool parameter from file >*/

bool sf_histbools (sf_file file, const char* key,
		   /*@out@*/ bool* par, size_t n) ;
/*< read a bool array of size n parameter from file >*/

char* sf_histstring (sf_file file, const char* key) ;
/*< read a string parameter from file (returns NULL on failure) >*/

void sf_fileflush (sf_file file, sf_file src);
/*< outputs parameter to a file (initially from source src)
---
Prepares file for writing binary data >*/

void sf_putint (sf_file file, const char* key, int par);
/*< put an int parameter to a file >*/

void sf_putints (sf_file file, const char* key, const int* par, size_t n);
/*< put an int array of size n parameter to a file >*/


void sf_putfloat (sf_file file, const char* key,float par);
/*< put a float parameter to a file >*/

void sf_putstring (sf_file file, const char* key,const char* par);
/*< put a string parameter to a file >*/

void sf_putline (sf_file file, const char* line);
/*< put a string line to a file >*/

void sf_setaformat (const char* format /* number format (.i.e "%5g") */, 
		    int line /* numbers in line */ );
/*< Set format for ascii output >*/

#ifndef __cplusplus

void sf_complexwrite (float complex* arr, size_t size, sf_file file);
/*< write a complex array arr[size] to file >*/

void sf_complexread (/*@out@*/ float complex* arr, size_t size, sf_file file);
/*< read a complex array arr[size] from file >*/

#endif /* c++ */

void sf_charwrite (char* arr, size_t size, sf_file file);
/*< write a char array arr[size] to file >*/

void sf_ucharwrite (unsigned char* arr, size_t size, sf_file file);
/*< write an unsigned char array arr[size] to file >*/

void sf_charread (/*@out@*/ char* arr, size_t size, sf_file file);
/*< read a char array arr[size] from file >*/

void sf_ucharread (/*@out@*/ unsigned char* arr, size_t size, sf_file file);
/*< read a uchar array arr[size] from file >*/

void sf_intwrite (int* arr, size_t size, sf_file file);
/*< write an int array arr[size] to file >*/

void sf_intread (/*@out@*/ int* arr, size_t size, sf_file file);
/*< read an int array arr[size] from file >*/

void sf_floatwrite (float* arr, size_t size, sf_file file);
/*< write a float array arr[size] to file >*/

void sf_floatread (/*@out@*/ float* arr, size_t size, sf_file file);
/*< read a float array arr[size] from file >*/

off_t sf_bytes (sf_file file);
/*< Count the file data size (in bytes) >*/

off_t sf_tell (sf_file file);
/*< Find position in file >*/

FILE *sf_tempfile(char** dataname, const char* mode);
/*< Create a temporary file with a unique name >*/

void sf_seek (sf_file file, off_t offset, int whence);
/*< Seek to a position in file. Follows fseek convention. >*/

void sf_unpipe (sf_file file, off_t size) ;
/*< Redirect a pipe input to a direct access file >*/

void sf_close(void);
/*< Remove temporary file, created by sf_unpipe >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_point_h
#define _sf_point_h


/* distance */
#define DST2d(A,B)   ( (B.x-A.x)*(B.x-A.x)+(B.z-A.z)*(B.z-A.z) ) 
/*^*/
/* vector product magnitude (Jacobian) */
#define JAC2d(O,A,B) ( (A.x-O.x)*(B.z-O.z)-(B.x-O.x)*(A.z-O.z) )

typedef struct{
    double x,z;   /* location */
    float  v;     /* value    */
}pt2d;

typedef struct{
    double x,y,z; /* location */
    float  v;     /* value    */
}pt3d;

void printpt2d(pt2d P);
/*< print point info  >*/

void printpt3d(pt3d P);
/*< print point info  >*/

void writept2d(sf_file F, pt2d *v, int n, int k);
/*< output point2d vector >*/

void writept3d(sf_file F, pt3d *v, int n, int k);
/*< output point3d vector >*/

void readpt2d(sf_file F, pt2d *v, int n, int k);
/*< input point2d vector >*/

void readpt3d(sf_file F, pt3d *v, int n, int k);
/*< input point3d vector >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_pqueue_h
#define _sf_pqueue_h

enum {SF_IN, SF_FRONT, SF_OUT};

void sf_pqueue_init (int n);
/*< Initialize heap with the maximum size >*/

void sf_pqueue_start (void);
/*< Set starting values >*/

void sf_pqueue_close (void);
/*< Free the allocated storage >*/

void sf_pqueue_insert (float* v);
/*< Insert an element >*/

float* sf_pqueue_extract (void);
/*< Extract the smallest element >*/

void sf_pqueue_update (float **v);
/*< restore the heap: the value has been altered >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_prefilter_h
#define _sf_prefilter_h

void sf_prefilter_init (int nw     /* spline order */, 
			int nt_in  /* temporary storage length */, 
			int pad_in /* padding */);
/*< initialize >*/

void sf_prefilter_apply (int nd     /* data length */, 
		      float* dat /* in - data, out - coefficients */);
/*< Convert 1-D data to spline coefficients >*/

void sf_prefilter (int dim    /* number of dimensions */, 
		int* n     /* data size [dim] */, 
		float* dat /* in - data, out - coefficients */);
/*< Convert N-D data to spline coefficients >*/

void sf_prefilter_close( void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_recfilt_h
#define _sf_recfilt_h


void sf_recfilt_init( int nd    /* data size */, 
		   int nb    /* filter size */, 
		   float* bb /* filter [nb] */) ;
/*< initialize >*/

void sf_recfilt_lop( bool adj, bool add, int nx, int ny, float* xx, float*yy) ;
/*< linear operator >*/

void sf_recfilt_close (void) ;
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_quantile_h
#define _sf_quantile_h

float sf_quantile(int q    /* quantile */, 
		  int n    /* array length */, 
		  float* a /* array [n] */) ;
/*< find quantile (caution: a is changed) >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_quadratic_h
#define _sf_quadratic_h

#include <float.h>

#define SF_EPS FLT_EPSILON
#define SF_HUGE FLT_MAX

float sf_quadratic_solve (float a, float b, float c) ;
/*< solves a x^2 + 2 b x + c == 0 for smallest positive x >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_segy_h
#define _sf_segy_h


#define SF_SEGY_FORMAT  24
#define SF_SEGY_NS      20
#define SF_SEGY_DT      16


enum {
    SF_EBCBYTES=3200,	/* Bytes in the card image EBCDIC block */
    SF_BNYBYTES=400,	/* Bytes in the binary coded block	*/
    SF_HDRBYTES=240,	/* Bytes in the tape trace header	*/
    SF_NKEYS=71,	/* Number of mandated header fields	*/
    SF_BHKEYS=27	/* Number of mandated binary fields	*/
};

bool sf_endian (void);
/*< Endianness test, returns true for little-endian machines >*/

void sf_ebc2asc (int narr, char* arr);
/*< Convert char array arrr[narr]: EBC to ASCII >*/

void sf_asc2ebc (int narr, char* arr);
/*< Convert char array arrr[narr]: ASCII to EBC >*/


int sf_segyformat (const char* bhead);
/*< extracts SEGY format from binary header >*/

int sf_segyns (const char* bhead);
/*< extracts ns (number of samples) from binary header >*/

float sf_segydt (const char* bhead);
/*< extracts dt (sampling) from binary header >*/

void sf_segy2trace(const char* buf, float* trace, int ns, int format);
/*< Extract a floating-point trace[nt] from buffer buf.
---
format: 1: IBM, 2: int4, 3: int2
>*/

void sf_trace2segy(char* buf, const float* trace, int ns, int format);
/*< Convert a floating-point trace[ns] to buffer buf.
---
format: 1: IBM, 2: int4, 3: int2
>*/

void sf_segy2head(const char* buf, int* trace, int nk);
/*< Create an integer trace header trace[nk] from buffer buf >*/

int sf_segykey (const char* key) ;
/*< Extract a SEGY key value >*/

char* sf_segykeyword (int k) ;
/*< Find a SEGY key from its number >*/

void sf_head2segy(char* buf, const int* trace, int nk);
/*< Convert an integer trace[nk] to buffer buf >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_stack_h
#define _sf_stack_h


typedef struct sf_Stack *sf_stack;

sf_stack sf_stack_init (size_t size);
/*< create a stack >*/

void sf_stack_print (sf_stack s);
/*< print out a stack (for debugging) >*/

int sf_stack_get (sf_stack s) ;
/*< extract stack length >*/

void sf_stack_set (sf_stack s, int pos) ;
/*< set stack position >*/

void sf_push(sf_stack s, void *data, int type);
/*< push data into stack (requires unique data for each push) >*/

void* sf_pop(sf_stack s);
/*< pop data from stack >*/

bool sf_full (sf_stack s);
/*< test if the stack is full >*/

int sf_top(sf_stack s);
/*< return the top type >*/

void sf_stack_close(sf_stack s);
/*< free allocated memory >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_tent2_h
#define _sf_tent2_h

void sf_tent2 (int dim          /* number of dimensions */, 
	       const int* nwind /* window size [dim] */, 
	       float* windwt    /* window weight */);
/*< define window weight >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_triangle_h
#define _sf_triangle_h


typedef struct sf_Triangle *sf_triangle;
/* abstract data type */

sf_triangle sf_triangle_init (int nbox /* triangle length */, 
			      int ndat /* data length */);
/*< initialize >*/

void sf_smooth (sf_triangle tr  /* smoothing object */, 
		int o, int d    /* trace sampling */, 
		bool der        /* if derivative */, 
		float *x        /* data (smoothed in place) */);
/*< apply triangle smoothing >*/

void sf_smooth2 (sf_triangle tr  /* smoothing object */, 
		 int o, int d    /* trace sampling */, 
		 bool der        /* if derivative */, 
		 float *x        /* data (smoothed in place) */);
/*< apply adjoint triangle smoothing >*/

void  sf_triangle_close(sf_triangle tr);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_triangle1_h
#define _sf_triangle1_h


void sf_triangle1m_init (int nbox /* triangle size */, 
			int ndat /* data size */);
/*< initialize >*/

void sf_triangle1m_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

void sf_triangle1m_close(void);
/*< free allocated storage >*/

void sf_triangle1_init (int nbox /* triangle size */, 
			int ndat /* data size */);
/*< initialize >*/

void sf_triangle1_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

void sf_triangle1_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_tridiagonal_h
#define _sf_tridiagonal_h

typedef struct sf_Tris *sf_tris;
/* abstract data type */

sf_tris sf_tridiagonal_init (int n /* matrix size */);
/*< initialize >*/

void sf_tridiagonal_define (sf_tris slv    /* solver object */, 
			 float* diag /* diagonal */, 
			 float* offd /* off-diagonal */);
/*< fill the matrix >*/

void sf_tridiagonal_const_define (sf_tris slv   /* solver object */, 
			       float diag /* diagonal */, 
			       float offd /* off-diagonal */);
/*< fill the matrix for the Toeplitz case >*/

void sf_tridiagonal_solve (sf_tris slv /* solver object */, 
			float* b /* in - right-hand side, out - solution */);
/*< invert the matrix >*/

void sf_tridiagonal_close (sf_tris slv);
/*< free allocated storage >*/

#endif
#ifndef KISS_FFT_H
#define KISS_FFT_H

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 ATTENTION!
 If you would like a :
 -- a utility that will handle the caching of fft objects
 -- real-only FFT
 -- a multi-dimensional FFT
 -- a command-line utility to perform ffts
 -- a command-line utility to perform fast-convolution filtering

 then see tools/
 */

#ifdef FIXED_POINT
# define kiss_fft_scalar short
#else
# ifndef kiss_fft_scalar
/*  default is float */
#   define kiss_fft_scalar float
# endif
#endif

typedef struct {
    kiss_fft_scalar r;
    kiss_fft_scalar i;
}kiss_fft_cpx;

typedef struct kiss_fft_state* kiss_fft_cfg;

/* 
 *  kiss_fft_alloc
 *  
 *  Initialize a FFT (or IFFT) algorithm's cfg/state buffer.
 *
 *  typical usage:      kiss_fft_cfg mycfg=kiss_fft_alloc(1024,0,NULL,NULL);
 *
 *  The return value from fft_alloc is a cfg buffer used internally
 *  by the fft routine or NULL.
 *
 *  If lenmem is NULL, then kiss_fft_alloc will allocate a cfg buffer using malloc.
 *  The returned value should be free()d when done to avoid memory leaks.
 *  
 *  The state can be placed in a user supplied buffer 'mem':
 *  If lenmem is not NULL and mem is not NULL and *lenmem is large enough,
 *      then the function places the cfg in mem and the size used in *lenmem
 *      and returns mem.
 *  
 *  If lenmem is not NULL and ( mem is NULL or *lenmem is not large enough),
 *      then the function returns NULL and places the minimum cfg 
 *      buffer size in *lenmem.
 * */

kiss_fft_cfg kiss_fft_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem); 

/*
 * kiss_fft(cfg,in_out_buf)
 *
 * Perform an FFT on a complex input buffer.
 * for a forward FFT,
 * fin should be  f[0] , f[1] , ... ,f[nfft-1]
 * fout will be   F[0] , F[1] , ... ,F[nfft-1]
 * Note that each element is complex and can be accessed like
    f[k].r and f[k].i
 * */
void kiss_fft(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout);

void kiss_fft_stride(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout,int fin_stride);

/* If kiss_fft_alloc allocated a buffer, it is one contiguous 
   buffer and can be simply free()d when no longer needed*/
#define kiss_fft_free free

#ifdef __cplusplus
} 
#endif

#endif
#ifndef KISS_FFT_H
#define KISS_FFT_H

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 ATTENTION!
 If you would like a :
 -- a utility that will handle the caching of fft objects
 -- real-only FFT
 -- a multi-dimensional FFT
 -- a command-line utility to perform ffts
 -- a command-line utility to perform fast-convolution filtering

 then see tools/
 */

#ifdef FIXED_POINT
# define kiss_fft_scalar short
#else
# ifndef kiss_fft_scalar
/*  default is float */
#   define kiss_fft_scalar float
# endif
#endif

typedef struct {
    kiss_fft_scalar r;
    kiss_fft_scalar i;
}kiss_fft_cpx;

typedef struct kiss_fft_state* kiss_fft_cfg;

/* 
 *  kiss_fft_alloc
 *  
 *  Initialize a FFT (or IFFT) algorithm's cfg/state buffer.
 *
 *  typical usage:      kiss_fft_cfg mycfg=kiss_fft_alloc(1024,0,NULL,NULL);
 *
 *  The return value from fft_alloc is a cfg buffer used internally
 *  by the fft routine or NULL.
 *
 *  If lenmem is NULL, then kiss_fft_alloc will allocate a cfg buffer using malloc.
 *  The returned value should be free()d when done to avoid memory leaks.
 *  
 *  The state can be placed in a user supplied buffer 'mem':
 *  If lenmem is not NULL and mem is not NULL and *lenmem is large enough,
 *      then the function places the cfg in mem and the size used in *lenmem
 *      and returns mem.
 *  
 *  If lenmem is not NULL and ( mem is NULL or *lenmem is not large enough),
 *      then the function returns NULL and places the minimum cfg 
 *      buffer size in *lenmem.
 * */

kiss_fft_cfg kiss_fft_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem); 

/*
 * kiss_fft(cfg,in_out_buf)
 *
 * Perform an FFT on a complex input buffer.
 * for a forward FFT,
 * fin should be  f[0] , f[1] , ... ,f[nfft-1]
 * fout will be   F[0] , F[1] , ... ,F[nfft-1]
 * Note that each element is complex and can be accessed like
    f[k].r and f[k].i
 * */
void kiss_fft(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout);

void kiss_fft_stride(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout,int fin_stride);

/* If kiss_fft_alloc allocated a buffer, it is one contiguous 
   buffer and can be simply free()d when no longer needed*/
#define kiss_fft_free free

#ifdef __cplusplus
} 
#endif

#endif
#ifndef KISS_FTR_H
#define KISS_FTR_H

#ifdef __cplusplus
extern "C" {
#endif

    
/* 
 
 Real optimized version can save about 45% cpu time vs. complex fft of a real seq.

 
 
 */

typedef struct kiss_fftr_state *kiss_fftr_cfg;


kiss_fftr_cfg kiss_fftr_alloc(int nfft,int inverse_fft,void * mem, size_t * lenmem);
/*
 nfft must be even

 If you don't care to allocate space, use mem = lenmem = NULL 
*/


void kiss_fftr(kiss_fftr_cfg cfg,const kiss_fft_scalar *timedata,kiss_fft_cpx *freqdata);
/*
 input timedata has nfft scalar points
 output freqdata has nfft/2+1 complex points
*/

void kiss_fftri(kiss_fftr_cfg cfg,const kiss_fft_cpx *freqdata,kiss_fft_scalar *timedata);
/*
 input freqdata has  nfft/2+1 complex points
 output timedata has nfft scalar points
*/

#define kiss_fftr_free free

#ifdef __cplusplus
}
#endif
#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _allp3_h
#define _allp3_h

typedef struct Allpass *allpass;
/* abstract data type */

allpass allpass_init(int nw                 /* filter size (1,2,3) */, 
		     int nj                 /* filter step */, 
		     int nx, int ny, int nz /* data size */, 
		     float *pp              /* data [nz*ny*nx] */);
/*< Initialize >*/

void allpass1 (bool der         /* derivative flag */, 
	       const allpass ap /* PWD object */, 
	       float* xx        /* input */, 
	       float* yy        /* output */);
/*< in-line plane-wave destruction >*/

void allpass2 (bool der         /* derivative flag */, 
	       const allpass ap /* PWD object */, 
	       float* xx        /* input */, 
	       float* yy        /* output */);
/*< cross-line plane-wave destruction >*/

void allpass3_init (allpass ap, allpass aq);
/*< Initialize linear operator >*/

void allpass3_lop (bool adj, bool add, int n1, int n2, float* xx, float* yy);
/*< PWD as linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _apfilt_h
#define _apfilt_h

void passfilter (int nw   /* size */, 
		 float p  /* slope */, 
		 float* a /* output filter [2*nw+1] */);
/*< find filter coefficients >*/

void aderfilter (int nw   /* size */, 
		 float p  /* slope */, 
		 float* a /* output filter [2*nw+1] */);
/*< find coefficients for filter derivative >*/

#endif
/* Operator types for linear solvers. */
/*
  Copyright (C) 2004 University of Texas at Austin
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _sf__solver_h
#define _sf__solver_h


typedef void (*sf_operator)(bool,bool,int,int,float*,float*);
typedef void (*sf_solverstep)(bool,int,int,float*,
			   const float*,float*,const float*);
typedef void (*sf_weight)(int,const float*,float*);
/*^*/

#ifndef __cplusplus
typedef void (*sf_coperator)(bool,bool,int,int,float complex*,float complex*);
typedef void (*sf_csolverstep)(bool,int,int,float complex*,
			       const float complex*,float complex*,
			       const float complex*);
typedef void (*sf_cweight)(int,const float complex*,float*);
#endif 
/*^*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_conjgrad_h
#define _sf_conjgrad_h


void sf_conjgrad_init(int np1     /* preconditioned size */, 
		      int nx1     /* model size */, 
		      int nd1     /* data size */, 
		      int nr1     /* residual size */, 
		      float eps1  /* scaling */,
		      float tol1  /* tolerance */, 
		      bool verb1  /* verbosity flag */, 
		      bool hasp01 /* if has initial model */) ;
/*< solver constructor >*/

void sf_conjgrad_close(void) ;
/*< Free allocated space >*/

void sf_conjgrad(sf_operator prec  /* data preconditioning */, 
		 sf_operator oper  /* linear operator */, 
		 sf_operator shape /* shaping operator */, 
		 float* p          /* preconditioned model */, 
		 float* x          /* estimated model */, 
		 float* dat        /* data */, 
		 int niter         /* number of iterations */) ;
/*< Conjugate gradient solver with shaping >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_decart_h
#define _sf_decart_h

void sf_line2cart( int dim       /* number of dimensions */, 
		   const int* nn /* box size [dim] */, 
		   int i         /* line coordinate */, 
		   int* ii       /* cartesian coordinates [dim] */);
/*< Convert line to Cartesian >*/

int sf_cart2line( int dim       /* number of dimensions */, 
		  const int* nn /* box size [dim] */, 
		  const int* ii /* cartesian coordinates [dim] */) ;
/*< Convert Cartesian to line >*/

int sf_first_index (int i        /* dimension [0...dim-1] */, 
		    int j        /* line coordinate */, 
		    int dim      /* number of dimensions */, 
		    const int *n /* box size [dim] */, 
		    const int *s /* step [dim] */);
/*< Find first index for multidimensional transforms >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _dip3_h
#define _dip3_h

void dip3_init(int m1, int m2, int m3       /* dimensions */, 
	       int* rect                    /* smoothing radius [3] */, 
	       int niter                    /* number of iterations */);
/*< initialize >*/

void dip3_close(void);
/*< free allocated storage >*/

void dip3(int dip                 /* 1 - inline, 2 - crossline */, 
	  int niter               /* number of nonlinear iterations */, 
	  int nw                  /* filter size */, 
	  int nj                  /* filter stretch for aliasing */, 
	  bool verb               /* verbosity */, 
	  float *u                /* input data */, 
	  float* p                /* output dip */, 
	  bool* mask              /* input mask for known data */,
	  float pmin, float pmax  /* minimum and maximum dip */);
/*< estimate local dip >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _divn_h
#define _divn_h

void divn_init(int ndim   /* number of dimensions */, 
	       int nd     /* data size */, 
	       int *ndat  /* data dimensions [ndim] */, 
	       int *nbox  /* smoothing radius [ndim] */, 
	       int niter1 /* number of iterations */) ;
/*< initialize >*/

void divn_close (void);
/*< free allocated storage >*/

void divn (float* num, float* den,  float* rat);
/*< smoothly divide rat=num/den >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _trianglen_h
#define _trianglen_h


void trianglen_init (int ndim  /* number of dimensions */, 
		     int *nbox /* triangle radius [ndim] */, 
		     int *ndat /* data dimensions [ndim] */);
/*< initialize >*/

void trianglen_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

void trianglen_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _weight_h
#define _weight_h


void weight_init(float *w1);
/*< initialize >*/

void weight_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_file_h
#define _sf_file_h

#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>

#include <stdio.h>


#define SF_MAX_DIM 9

typedef struct sf_File *sf_file;

typedef enum {SF_UCHAR, SF_CHAR, SF_INT, SF_FLOAT, SF_COMPLEX} sf_datatype;
typedef enum {SF_ASCII, SF_XDR, SF_NATIVE} sf_dataform;

sf_file sf_input (/*@null@*/ const char* tag);
/*< Create an input file structure >*/

sf_file sf_output (/*@null@*/ const char* tag);
/*< Create an output file structure.
---
Should do output after sf_input. >*/

sf_datatype sf_gettype (sf_file file);
/*< return file type >*/

sf_dataform sf_getform (sf_file file);
/*< return file form >*/

size_t sf_esize(sf_file file);
/*< return element size >*/


void sf_settype (sf_file file, sf_datatype type);
/*< set file type >*/

void sf_setpars (sf_file file);
/*< change parameters to those from the command line >*/

void sf_setform (sf_file file, sf_dataform form);
/*< set file form >*/

void sf_setformat (sf_file file, const char* format);
/*< Set file format.
---
format has a form "form_type", i.e. native_float, ascii_int, etc.
>*/

void sf_fileclose (sf_file file) ;
/*< close a file and free allocated space >*/

bool sf_histint (sf_file file, const char* key,/*@out@*/ int* par);
/*< read an int parameter from file >*/

bool sf_histints (sf_file file, const char* key,/*@out@*/ int* par,size_t n) ;
/*< read an int array of size n parameter from file >*/

bool sf_histfloat (sf_file file, const char* key,/*@out@*/ float* par) ;
/*< read a float parameter from file >*/

bool sf_histdouble (sf_file file, const char* key,/*@out@*/ double* par) ;
/*< read a float parameter from file >*/

bool sf_histfloats (sf_file file, const char* key,
		    /*@out@*/ float* par,size_t n) ;
/*< read a float array of size n parameter from file >*/

bool sf_histbool (sf_file file, const char* key,/*@out@*/ bool* par) ;
/*< read a bool parameter from file >*/

bool sf_histbools (sf_file file, const char* key,
		   /*@out@*/ bool* par, size_t n) ;
/*< read a bool array of size n parameter from file >*/

char* sf_histstring (sf_file file, const char* key) ;
/*< read a string parameter from file (returns NULL on failure) >*/

void sf_fileflush (sf_file file, sf_file src);
/*< outputs parameter to a file (initially from source src)
---
Prepares file for writing binary data >*/

void sf_putint (sf_file file, const char* key, int par);
/*< put an int parameter to a file >*/

void sf_putints (sf_file file, const char* key, const int* par, size_t n);
/*< put an int array of size n parameter to a file >*/


void sf_putfloat (sf_file file, const char* key,float par);
/*< put a float parameter to a file >*/

void sf_putstring (sf_file file, const char* key,const char* par);
/*< put a string parameter to a file >*/

void sf_putline (sf_file file, const char* line);
/*< put a string line to a file >*/

void sf_setaformat (const char* format /* number format (.i.e "%5g") */, 
		    int line /* numbers in line */ );
/*< Set format for ascii output >*/

#ifndef __cplusplus

void sf_complexwrite (float complex* arr, size_t size, sf_file file);
/*< write a complex array arr[size] to file >*/

void sf_complexread (/*@out@*/ float complex* arr, size_t size, sf_file file);
/*< read a complex array arr[size] from file >*/

#endif /* c++ */

void sf_charwrite (char* arr, size_t size, sf_file file);
/*< write a char array arr[size] to file >*/

void sf_ucharwrite (unsigned char* arr, size_t size, sf_file file);
/*< write an unsigned char array arr[size] to file >*/

void sf_charread (/*@out@*/ char* arr, size_t size, sf_file file);
/*< read a char array arr[size] from file >*/

void sf_ucharread (/*@out@*/ unsigned char* arr, size_t size, sf_file file);
/*< read a uchar array arr[size] from file >*/

void sf_intwrite (int* arr, size_t size, sf_file file);
/*< write an int array arr[size] to file >*/

void sf_intread (/*@out@*/ int* arr, size_t size, sf_file file);
/*< read an int array arr[size] from file >*/

void sf_floatwrite (float* arr, size_t size, sf_file file);
/*< write a float array arr[size] to file >*/

void sf_floatread (/*@out@*/ float* arr, size_t size, sf_file file);
/*< read a float array arr[size] from file >*/

off_t sf_bytes (sf_file file);
/*< Count the file data size (in bytes) >*/

off_t sf_tell (sf_file file);
/*< Find position in file >*/

FILE *sf_tempfile(char** dataname, const char* mode);
/*< Create a temporary file with a unique name >*/

void sf_seek (sf_file file, off_t offset, int whence);
/*< Seek to a position in file. Follows fseek convention. >*/

void sf_unpipe (sf_file file, off_t size) ;
/*< Redirect a pipe input to a direct access file >*/

void sf_close(void);
/*< Remove temporary file, created by sf_unpipe >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_simtab_h
#define _sf_simtab_h

#include <stdio.h>


#define SF_EOL '\014'
#define SF_EOT '\004'

typedef struct sf_SimTab *sf_simtab; /* Simbol Table structure */

sf_simtab sf_simtab_init(int size);
/*< Create simbol table. >*/

void sf_simtab_close(sf_simtab table);
/*< Free allocated memory >*/

void sf_simtab_enter(sf_simtab table, const char *key, const char* val);
/*< Add an entry key=val to the table >*/

char *sf_simtab_get(sf_simtab table, const char *key) ;
/*< extract a value from the table >*/

bool sf_simtab_getint (sf_simtab table, const char* key,/*@out@*/ int* par);
/*< extract an int parameter from the table >*/

bool sf_simtab_getfloat (sf_simtab table, const char* key,/*@out@*/ float* par);
/*< extract a float parameter from the table >*/

bool sf_simtab_getdouble (sf_simtab table, const char* key,/*@out@*/ double* par);
/*< extract a double parameter from the table >*/

bool sf_simtab_getfloats (sf_simtab table, const char* key,
			  /*@out@*/ float* par,size_t n);
/*< extract a float array parameter from the table >*/

char* sf_simtab_getstring (sf_simtab table, const char* key) ;
/*< extract a string parameter from the table >*/

bool sf_simtab_getbool (sf_simtab table, const char* key,/*@out@*/ bool *par);
/*< extract a bool parameter from the table >*/

bool sf_simtab_getbools (sf_simtab table, const char* key,
			 /*@out@*/bool *par,size_t n);
/*< extract a bool array parameter from the table >*/

bool sf_simtab_getints (sf_simtab table, const char* key,
			/*@out@*/ int *par,size_t n);
/*< extract an int array parameter from the table >*/

bool sf_simtab_getstrings (sf_simtab table, const char* key,
			   /*@out@*/ char **par,size_t n);
/*< extract a string array parameter from the table >*/

void sf_simtab_put (sf_simtab table, const char *keyval) ;
/*< put a key=val string to the table >*/

void sf_simtab_input (sf_simtab table, FILE* fp) ;
/*< extract parameters from a file >*/

void sf_simtab_output (sf_simtab table, FILE* fp) ;
/*< output parameters to a file >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_getpar_h
#define _sf_getpar_h


void sf_init(int argc,char *argv[]) ;
/*< initialize parameter table from command-line arguments >*/

void sf_parclose (void);
/*< close parameter table and free space >*/

void sf_parout (FILE *file);
/*< write the parameters to a file >*/

char* sf_getprog (void) ;
/*< returns name of the running program >*/

char* sf_getuser (void) ;
/*< returns user name >*/

char* sf_gethost (void) ;
/*< returns host name >*/

bool sf_getint (const char* key,/*@out@*/ int* par) ;
/*< get an int parameter from the command line >*/

bool sf_getints (const char* key,/*@out@*/ int* par,size_t n) ;
/*< get an int array parameter (comma-separated) from the command line >*/

bool sf_getfloat (const char* key,/*@out@*/ float* par) ;
/*< get a float parameter from the command line >*/

bool sf_getdouble (const char* key,/*@out@*/ double* par) ;
/*< get a double parameter from the command line >*/

bool sf_getfloats (const char* key,/*@out@*/ float* par,size_t n) ;
/*< get a float array parameter from the command line >*/

char* sf_getstring (const char* key) ;
/*< get a string parameter from the command line >*/

bool sf_getstrings (const char* key,/*@out@*/ char** par,size_t n) ;
/*< get a string array parameter from the command line >*/

bool sf_getbool (const char* key,/*@out@*/ bool* par);
/*< get a bool parameter from the command line >*/

bool sf_getbools (const char* key,/*@out@*/ bool* par,size_t n) ;
/*< get a bool array parameter from the command line >*/

sf_simtab sf_getpars (void);
/*< provide access to the parameter table >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mask6_h
#define _mask6_h


void mask32 (int nw                 /* filter size */, 
	     int nj1, int nj2       /* dealiasing stretch */, 
	     int nx, int ny, int nz /* data size */, 
	     float *yy              /* data [nz][ny][nx] */, 
	     bool *m1               /* first dip mask [nz][ny][nx] */, 
	     bool *m2               /* second dip mask [nz][ny][nx] */);
/*< two-dip masks in 3-D >*/

void mask3 (int nw         /* filter size */, 
	    int nj         /* dealiasing stretch */, 
	    int nx, int ny /* data size */, 
	    float **yy     /* data */, 
	    bool **mm      /* mask */) ;
/*< one-dip mask in 2-D >*/

void mask6 (int nw           /* filter size */, 
	    int nj1, int nj2 /* dealiasing stretch */, 
	    int nx, int ny   /* data size */, 
	    float *yy       /* data [ny][nx] */, 
	    bool *mm        /* mask [ny][nx] */) ;
/*< two-dip mask in 2-D >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _oc_h
#define _oc_h

#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>


void oc_invert(off_t n, FILE *wall);
/*< write out 1/wall >*/

void oc_zero (off_t n, FILE *wall) ;
/*< set wall=0 >*/

void oc_dump (off_t n, FILE *wall, sf_file out) ;
/*< write wall to out >*/

void oc_divide (off_t n, FILE *data, FILE *wall, sf_file out) ;
/*< write data/wall to out >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _ocpatch_h
#define _ocpatch_h

#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>


void ocpatch_init(int dim     /* number of dimensions */, 
		  int nw      /* total patch size */, 
		  int np      /* total number of patches */, 
		  int* npatch /* number of patches [dim] */, 
		  int* nwall  /* data size [dim] */, 
		  int* nwind  /* patch size [dim] */);
/*< initialize >*/

void ocpatch_close(void);
/*< free allocated storage >*/

void ocpatch_lop (int ip      /* patch number */, 
		  bool adj    /* pull or push */, 
		  FILE *wall  /* data */, 
		  float* wind /* patch */);
/*< apply patching >*/

void ocpatch_flop (int ip       /* patch number */, 
		   bool adj     /* pull or push */, 
		   sf_file wall /* data */, 
		   float* wind  /* patch */);
/*< apply patching with RSF files >*/

#endif
#ifndef _sf_defs_h
#define _sf_defs_h

#define SF_MAX(a,b) ((a) < (b) ? (b) : (a))
#define SF_MIN(a,b) ((a) < (b) ? (a) : (b))

#define SF_ABS(a)   ((a) >= 0  ? (a) : (-(a)))

#define SF_SIG(a)   ((a) >= 0  ?  1  :  -1 )

#define SF_PI (3.141592653589793)

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_tent2_h
#define _sf_tent2_h

void sf_tent2 (int dim          /* number of dimensions */, 
	       const int* nwind /* window size [dim] */, 
	       float* windwt    /* window weight */);
/*< define window weight >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _trianglen_h
#define _trianglen_h


void trianglen_init (int ndim  /* number of dimensions */, 
		     int *nbox /* triangle radius [ndim] */, 
		     int *ndat /* data dimensions [ndim] */);
/*< initialize >*/

void trianglen_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

void trianglen_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwd_h
#define _pwd_h


typedef struct Pwd *pwd; /* abstract data type */

pwd pwd_init(int n1 /* trace length */, 
	     int nw /* filter order */);
/*< initialize >*/

void pwd_close (pwd w);
/*< free allocated storage >*/

void pwd_define (bool adj        /* adjoint flag */, 
		 pwd w           /* pwd object */, 
		 const float* pp /* slope */, 
		 float* diag     /* defined diagonal */, 
		 float** offd    /* defined off-diagonal */);
/*< fill the matrix >*/

void pwd_set (bool adj   /* adjoint flag */,
	      pwd w      /* pwd object */, 
	      float* inp /* input */, 
	      float* out /* output */, 
	      float* tmp /* temporary storage */);
/*< matrix multiplication >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwdsl_h
#define _pwdsl_h


void pwdsl_init(int m1, int m2       /* data dimensions */, 
		int rect1, int rect2 /* triangle radius */,
		float eps            /* regularization parameter */);
/*< initialize >*/

void pwdsl_set(float **dip /* dip field [n2][n1] */);
/*< set the local slopes for applying the linear operator >*/

void dip_set(float *dip,int n1,int n2);

void pwdsl_close(void);
/*< free allocated storage >*/

void pwdsl_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _predict_h
#define _predict_h


void predict_init (int nx, int ny /* data size */, 
		   float e        /* regularization parameter */,
		   int k          /* radius */);
/*< initialize >*/

void predict_close (void);
/*< free allocated storage >*/

void predict_step(bool adj     /* adjoint flag */,
		  bool forw    /* forward or backward */, 
		  float* trace /* trace */, 
		  float* pp    /* slope */);
/*< prediction step >*/

void predict_set(float **dip1 /* dip field [n2][n1] */);
/*< set the local slopes for applying the linear operator >*/

void predict_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

void predicter_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

void subtracter_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

void subtract_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

void predict_flat(int i0     /* reference trace number */, 
		  float** d  /* input */, 
		  float** mm /* output */, 
		  float** pp /* slope */);
/*< predictive flattening >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _repeat_h
#define _repeat_h


void repeat_init(int m1            /* trace length */, 
		 int m2            /* number of traces */, 
		 sf_operator oper1 /* operator */);
/*< initialize >*/

void repeat_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< combined linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_files_h
#define _sf_files_h


int sf_filedims (sf_file file, /*@out@*/ int *n) ;
/*< Find file dimensions.
--- 
Outputs the number of dimensions dim and a dimension array n[dim] >*/

int sf_filesize (sf_file file) ;
/*< Find file size (product of all dimensions) >*/

int sf_leftsize (sf_file file, int dim) ;
/*< Find file size for dimensions greater than dim >*/

void sf_cp(sf_file in, sf_file out);
/*< Copy file in to file out >*/

void sf_rm(const char* filename, bool force, bool verb, bool inquire);
/*< Remove an RSF file.
---
force, verb, and inquire flags should behave similar to the corresponding flags in the Unix "rm" command. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_triangle1_h
#define _sf_triangle1_h


void sf_triangle1_init (int nbox /* triangle size */, 
			int ndat /* data size */);
/*< initialize >*/

void sf_triangle1_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

void sf_triangle1_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_banded_h
#define _sf_banded_h

typedef struct sf_Bands *sf_bands;
/* abstract data type */

sf_bands sf_banded_init (int n    /* matrix size */, 
		   int band /* band size */);
/*< initialize >*/

void sf_banded_define (sf_bands slv, 
		    float* diag  /* diagonal [n] */, 
		    float** offd /* off-diagonal [band][n] */);
/*< define the matrix >*/

void sf_banded_const_define (sf_bands slv, 
			  float diag        /* diagonal */, 
			  const float* offd /* off-diagonal [band] */);
/*< define matrix with constant diagonal coefficients >*/

void sf_banded_solve (sf_bands slv, float* b);
/*< invert (in place) >*/

void sf_banded_close (sf_bands slv);
/*< free allocated storage >*/

#endif
